   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.action_exec,"ax",@progbits
  12               	.global	action_exec
  14               	action_exec:
  15               	.LFB10:
  16               		.file 1 "../../tmk_core/common/action.c"
   1:../../tmk_core/common/action.c **** /*
   2:../../tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:../../tmk_core/common/action.c **** 
   4:../../tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:../../tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:../../tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:../../tmk_core/common/action.c **** (at your option) any later version.
   8:../../tmk_core/common/action.c **** 
   9:../../tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:../../tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:../../tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:../../tmk_core/common/action.c **** GNU General Public License for more details.
  13:../../tmk_core/common/action.c **** 
  14:../../tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:../../tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:../../tmk_core/common/action.c **** */
  17:../../tmk_core/common/action.c **** #include "host.h"
  18:../../tmk_core/common/action.c **** #include "keycode.h"
  19:../../tmk_core/common/action.c **** #include "keyboard.h"
  20:../../tmk_core/common/action.c **** #include "mousekey.h"
  21:../../tmk_core/common/action.c **** #include "command.h"
  22:../../tmk_core/common/action.c **** #include "led.h"
  23:../../tmk_core/common/action.c **** #include "backlight.h"
  24:../../tmk_core/common/action.c **** #include "action_layer.h"
  25:../../tmk_core/common/action.c **** #include "action_tapping.h"
  26:../../tmk_core/common/action.c **** #include "action_macro.h"
  27:../../tmk_core/common/action.c **** #include "action_util.h"
  28:../../tmk_core/common/action.c **** #include "action.h"
  29:../../tmk_core/common/action.c **** #include "hook.h"
  30:../../tmk_core/common/action.c **** #include "wait.h"
  31:../../tmk_core/common/action.c **** 
  32:../../tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  33:../../tmk_core/common/action.c **** #include "debug.h"
  34:../../tmk_core/common/action.c **** #else
  35:../../tmk_core/common/action.c **** #include "nodebug.h"
  36:../../tmk_core/common/action.c **** #endif
  37:../../tmk_core/common/action.c **** 
  38:../../tmk_core/common/action.c **** 
  39:../../tmk_core/common/action.c **** void action_exec(keyevent_t event)
  40:../../tmk_core/common/action.c **** {
  17               		.loc 1 40 0
  18               		.cfi_startproc
  19 0000 CF93      		push r28
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 28, -2
  23 0002 DF93      		push r29
  24               	.LCFI1:
  25               		.cfi_def_cfa_offset 4
  26               		.cfi_offset 29, -3
  27 0004 CDB7      		in r28,__SP_L__
  28 0006 DEB7      		in r29,__SP_H__
  29               	.LCFI2:
  30               		.cfi_def_cfa_register 28
  31 0008 2B97      		sbiw r28,11
  32               	.LCFI3:
  33               		.cfi_def_cfa_offset 15
  34 000a 0FB6      		in __tmp_reg__,__SREG__
  35 000c F894      		cli
  36 000e DEBF      		out __SP_H__,r29
  37 0010 0FBE      		out __SREG__,__tmp_reg__
  38 0012 CDBF      		out __SP_L__,r28
  39               	/* prologue: function */
  40               	/* frame size = 11 */
  41               	/* stack size = 13 */
  42               	.L__stack_usage = 13
  43 0014 4F83      		std Y+7,r20
  44 0016 5887      		std Y+8,r21
  45 0018 6987      		std Y+9,r22
  46 001a 7A87      		std Y+10,r23
  47 001c 8B87      		std Y+11,r24
  48               	.LVL0:
  49               	.LBB16:
  50               	.LBB17:
  51               		.file 2 "../../tmk_core/common/keyboard.h"
   1:../../tmk_core/common/keyboard.h **** /*
   2:../../tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:../../tmk_core/common/keyboard.h **** 
   4:../../tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:../../tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:../../tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:../../tmk_core/common/keyboard.h **** (at your option) any later version.
   8:../../tmk_core/common/keyboard.h **** 
   9:../../tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:../../tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:../../tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:../../tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:../../tmk_core/common/keyboard.h **** 
  14:../../tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:../../tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:../../tmk_core/common/keyboard.h **** */
  17:../../tmk_core/common/keyboard.h **** 
  18:../../tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:../../tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:../../tmk_core/common/keyboard.h **** 
  21:../../tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:../../tmk_core/common/keyboard.h **** #include <stdint.h>
  23:../../tmk_core/common/keyboard.h **** 
  24:../../tmk_core/common/keyboard.h **** 
  25:../../tmk_core/common/keyboard.h **** #ifdef __cplusplus
  26:../../tmk_core/common/keyboard.h **** extern "C" {
  27:../../tmk_core/common/keyboard.h **** #endif
  28:../../tmk_core/common/keyboard.h **** 
  29:../../tmk_core/common/keyboard.h **** /* key matrix position */
  30:../../tmk_core/common/keyboard.h **** typedef struct {
  31:../../tmk_core/common/keyboard.h ****     uint8_t col;
  32:../../tmk_core/common/keyboard.h ****     uint8_t row;
  33:../../tmk_core/common/keyboard.h **** } keypos_t;
  34:../../tmk_core/common/keyboard.h **** 
  35:../../tmk_core/common/keyboard.h **** /* key event */
  36:../../tmk_core/common/keyboard.h **** typedef struct {
  37:../../tmk_core/common/keyboard.h ****     keypos_t key;
  38:../../tmk_core/common/keyboard.h ****     bool     pressed;
  39:../../tmk_core/common/keyboard.h ****     uint16_t time;
  40:../../tmk_core/common/keyboard.h **** } keyevent_t;
  41:../../tmk_core/common/keyboard.h **** 
  42:../../tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  43:../../tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:../../tmk_core/common/keyboard.h **** 
  45:../../tmk_core/common/keyboard.h **** /* Rules for No Event:
  46:../../tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:../../tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:../../tmk_core/common/keyboard.h ****  */
  49:../../tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
  52               		.loc 2 49 0
  53 001e 8A85      		ldd r24,Y+10
  54 0020 9B85      		ldd r25,Y+11
  55 0022 892B      		or r24,r25
  56 0024 01F0      		breq .L6
  57 0026 5F3F      		cpi r21,lo8(-1)
  58 0028 01F0      		breq .L3
  59               	.L4:
  60 002a 80E0      		ldi r24,0
  61 002c 00C0      		rjmp .L2
  62               	.LVL1:
  63               	.L3:
  64 002e 4F3F      		cpi r20,lo8(-1)
  65 0030 01F4      		brne .L4
  66               	.L6:
  67 0032 81E0      		ldi r24,lo8(1)
  68               	.LVL2:
  69               	.L2:
  70               	.LBE17:
  71               	.LBE16:
  41:../../tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  72               		.loc 1 41 0
  73 0034 8111      		cpse r24,__zero_reg__
  74 0036 00C0      		rjmp .L5
  42:../../tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  43:../../tmk_core/common/action.c ****         dprint("EVENT: "); debug_event(event); dprintln();
  44:../../tmk_core/common/action.c ****         hook_matrix_change(event);
  75               		.loc 1 44 0
  76 0038 4F81      		ldd r20,Y+7
  77               	.LVL3:
  78 003a 5885      		ldd r21,Y+8
  79               	.LVL4:
  80 003c 6985      		ldd r22,Y+9
  81 003e 7A85      		ldd r23,Y+10
  82 0040 8B85      		ldd r24,Y+11
  83 0042 0E94 0000 		call hook_matrix_change
  84               	.LVL5:
  85               	.L5:
  45:../../tmk_core/common/action.c ****     }
  46:../../tmk_core/common/action.c **** 
  47:../../tmk_core/common/action.c ****     keyrecord_t record = { .event = event };
  86               		.loc 1 47 0
  87 0046 DE01      		movw r26,r28
  88 0048 1196      		adiw r26,1
  89 004a 86E0      		ldi r24,lo8(6)
  90 004c FD01      		movw r30,r26
  91               		0:
  92 004e 1192      		st Z+,__zero_reg__
  93 0050 8A95      		dec r24
  94 0052 01F4      		brne 0b
  95 0054 85E0      		ldi r24,lo8(5)
  96 0056 FE01      		movw r30,r28
  97 0058 3796      		adiw r30,7
  98               		0:
  99 005a 0190      		ld r0,Z+
 100 005c 0D92      		st X+,r0
 101 005e 8A95      		dec r24
 102 0060 01F4      		brne 0b
  48:../../tmk_core/common/action.c **** 
  49:../../tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  50:../../tmk_core/common/action.c ****     action_tapping_process(record);
 103               		.loc 1 50 0
 104 0062 4981      		ldd r20,Y+1
 105 0064 5A81      		ldd r21,Y+2
 106 0066 6B81      		ldd r22,Y+3
 107 0068 7C81      		ldd r23,Y+4
 108 006a 8D81      		ldd r24,Y+5
 109 006c 9E81      		ldd r25,Y+6
 110 006e 0E94 0000 		call action_tapping_process
 111               	.LVL6:
 112               	/* epilogue start */
  51:../../tmk_core/common/action.c **** #else
  52:../../tmk_core/common/action.c ****     process_action(&record);
  53:../../tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
  54:../../tmk_core/common/action.c ****         dprint("processed: "); debug_record(record); dprintln();
  55:../../tmk_core/common/action.c ****     }
  56:../../tmk_core/common/action.c **** #endif
  57:../../tmk_core/common/action.c **** }
 113               		.loc 1 57 0
 114 0072 2B96      		adiw r28,11
 115 0074 0FB6      		in __tmp_reg__,__SREG__
 116 0076 F894      		cli
 117 0078 DEBF      		out __SP_H__,r29
 118 007a 0FBE      		out __SREG__,__tmp_reg__
 119 007c CDBF      		out __SP_L__,r28
 120 007e DF91      		pop r29
 121 0080 CF91      		pop r28
 122 0082 0895      		ret
 123               		.cfi_endproc
 124               	.LFE10:
 126               		.section	.text.register_code,"ax",@progbits
 127               	.global	register_code
 129               	register_code:
 130               	.LFB12:
  58:../../tmk_core/common/action.c **** 
  59:../../tmk_core/common/action.c **** void process_action(keyrecord_t *record)
  60:../../tmk_core/common/action.c **** {
  61:../../tmk_core/common/action.c ****     keyevent_t event = record->event;
  62:../../tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  63:../../tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
  64:../../tmk_core/common/action.c **** #endif
  65:../../tmk_core/common/action.c **** 
  66:../../tmk_core/common/action.c ****     if (IS_NOEVENT(event)) { return; }
  67:../../tmk_core/common/action.c **** 
  68:../../tmk_core/common/action.c ****     action_t action = layer_switch_get_action(event.key);
  69:../../tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
  70:../../tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
  71:../../tmk_core/common/action.c ****     dprint(" layer_state: "); layer_debug();
  72:../../tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
  73:../../tmk_core/common/action.c **** #endif
  74:../../tmk_core/common/action.c ****     dprintln();
  75:../../tmk_core/common/action.c **** 
  76:../../tmk_core/common/action.c ****     switch (action.kind.id) {
  77:../../tmk_core/common/action.c ****         /* Key and Mods */
  78:../../tmk_core/common/action.c ****         case ACT_LMODS:
  79:../../tmk_core/common/action.c ****         case ACT_RMODS:
  80:../../tmk_core/common/action.c ****             {
  81:../../tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
  82:../../tmk_core/common/action.c ****                                                                 action.key.mods<<4;
  83:../../tmk_core/common/action.c ****                 if (event.pressed) {
  84:../../tmk_core/common/action.c ****                     if (mods) {
  85:../../tmk_core/common/action.c ****                         add_weak_mods(mods);
  86:../../tmk_core/common/action.c ****                         send_keyboard_report();
  87:../../tmk_core/common/action.c ****                     }
  88:../../tmk_core/common/action.c ****                     register_code(action.key.code);
  89:../../tmk_core/common/action.c ****                 } else {
  90:../../tmk_core/common/action.c ****                     unregister_code(action.key.code);
  91:../../tmk_core/common/action.c ****                     if (mods) {
  92:../../tmk_core/common/action.c ****                         del_weak_mods(mods);
  93:../../tmk_core/common/action.c ****                         send_keyboard_report();
  94:../../tmk_core/common/action.c ****                     }
  95:../../tmk_core/common/action.c ****                 }
  96:../../tmk_core/common/action.c ****             }
  97:../../tmk_core/common/action.c ****             break;
  98:../../tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  99:../../tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 100:../../tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 101:../../tmk_core/common/action.c ****             {
 102:../../tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 103:../../tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 104:../../tmk_core/common/action.c ****                 switch (action.key.code) {
 105:../../tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 106:../../tmk_core/common/action.c ****                     case MODS_ONESHOT:
 107:../../tmk_core/common/action.c ****                         // Oneshot modifier
 108:../../tmk_core/common/action.c ****                         if (event.pressed) {
 109:../../tmk_core/common/action.c ****                             if (tap_count == 0) {
 110:../../tmk_core/common/action.c ****                                 register_mods(mods);
 111:../../tmk_core/common/action.c ****                             }
 112:../../tmk_core/common/action.c ****                             else if (tap_count == 1) {
 113:../../tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 114:../../tmk_core/common/action.c ****                                 set_oneshot_mods(mods);
 115:../../tmk_core/common/action.c ****                             }
 116:../../tmk_core/common/action.c ****                             else {
 117:../../tmk_core/common/action.c ****                                 register_mods(mods);
 118:../../tmk_core/common/action.c ****                             }
 119:../../tmk_core/common/action.c ****                         } else {
 120:../../tmk_core/common/action.c ****                             if (tap_count == 0) {
 121:../../tmk_core/common/action.c ****                                 clear_oneshot_mods();
 122:../../tmk_core/common/action.c ****                                 unregister_mods(mods);
 123:../../tmk_core/common/action.c ****                             }
 124:../../tmk_core/common/action.c ****                             else if (tap_count == 1) {
 125:../../tmk_core/common/action.c ****                                 // Retain Oneshot mods
 126:../../tmk_core/common/action.c ****                             }
 127:../../tmk_core/common/action.c ****                             else {
 128:../../tmk_core/common/action.c ****                                 clear_oneshot_mods();
 129:../../tmk_core/common/action.c ****                                 unregister_mods(mods);
 130:../../tmk_core/common/action.c ****                             }
 131:../../tmk_core/common/action.c ****                         }
 132:../../tmk_core/common/action.c ****                         break;
 133:../../tmk_core/common/action.c ****     #endif
 134:../../tmk_core/common/action.c ****                     case MODS_TAP_TOGGLE:
 135:../../tmk_core/common/action.c ****                         if (event.pressed) {
 136:../../tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 137:../../tmk_core/common/action.c ****                                 if (mods & get_mods()) {
 138:../../tmk_core/common/action.c ****                                     dprint("MODS_TAP_TOGGLE: toggle mods off\n");
 139:../../tmk_core/common/action.c ****                                     unregister_mods(mods);
 140:../../tmk_core/common/action.c ****                                 } else {
 141:../../tmk_core/common/action.c ****                                     dprint("MODS_TAP_TOGGLE: toggle mods on\n");
 142:../../tmk_core/common/action.c ****                                     register_mods(mods);
 143:../../tmk_core/common/action.c ****                                 }
 144:../../tmk_core/common/action.c ****                             }
 145:../../tmk_core/common/action.c ****                         } else {
 146:../../tmk_core/common/action.c ****                             if (tap_count < TAPPING_TOGGLE) {
 147:../../tmk_core/common/action.c ****                                 dprint("MODS_TAP_TOGGLE: release : unregister_mods\n");
 148:../../tmk_core/common/action.c ****                                 unregister_mods(mods);
 149:../../tmk_core/common/action.c ****                             }
 150:../../tmk_core/common/action.c ****                         }
 151:../../tmk_core/common/action.c ****                         break;
 152:../../tmk_core/common/action.c ****                     default:
 153:../../tmk_core/common/action.c ****                         if (event.pressed) {
 154:../../tmk_core/common/action.c ****                             if (tap_count > 0) {
 155:../../tmk_core/common/action.c ****                                 if (record->tap.interrupted) {
 156:../../tmk_core/common/action.c ****                                     dprint("MODS_TAP: Tap: Cancel: add_mods\n");
 157:../../tmk_core/common/action.c ****                                     // ad hoc: set 0 to cancel tap
 158:../../tmk_core/common/action.c ****                                     record->tap.count = 0;
 159:../../tmk_core/common/action.c ****                                     register_mods(mods);
 160:../../tmk_core/common/action.c ****                                 } else {
 161:../../tmk_core/common/action.c ****                                     dprint("MODS_TAP: Tap: register_code\n");
 162:../../tmk_core/common/action.c ****                                     register_code(action.key.code);
 163:../../tmk_core/common/action.c ****                                 }
 164:../../tmk_core/common/action.c ****                             } else {
 165:../../tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 166:../../tmk_core/common/action.c ****                                 register_mods(mods);
 167:../../tmk_core/common/action.c ****                             }
 168:../../tmk_core/common/action.c ****                         } else {
 169:../../tmk_core/common/action.c ****                             if (tap_count > 0) {
 170:../../tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 171:../../tmk_core/common/action.c ****                                 unregister_code(action.key.code);
 172:../../tmk_core/common/action.c ****                             } else {
 173:../../tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 174:../../tmk_core/common/action.c ****                                 unregister_mods(mods);
 175:../../tmk_core/common/action.c ****                             }
 176:../../tmk_core/common/action.c ****                         }
 177:../../tmk_core/common/action.c ****                         break;
 178:../../tmk_core/common/action.c ****                 }
 179:../../tmk_core/common/action.c ****             }
 180:../../tmk_core/common/action.c ****             break;
 181:../../tmk_core/common/action.c **** #endif
 182:../../tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 183:../../tmk_core/common/action.c ****         /* other HID usage */
 184:../../tmk_core/common/action.c ****         case ACT_USAGE:
 185:../../tmk_core/common/action.c ****             switch (action.usage.page) {
 186:../../tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 187:../../tmk_core/common/action.c ****                     if (event.pressed) {
 188:../../tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 189:../../tmk_core/common/action.c ****                     } else {
 190:../../tmk_core/common/action.c ****                         host_system_send(0);
 191:../../tmk_core/common/action.c ****                     }
 192:../../tmk_core/common/action.c ****                     break;
 193:../../tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 194:../../tmk_core/common/action.c ****                     if (event.pressed) {
 195:../../tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 196:../../tmk_core/common/action.c ****                     } else {
 197:../../tmk_core/common/action.c ****                         host_consumer_send(0);
 198:../../tmk_core/common/action.c ****                     }
 199:../../tmk_core/common/action.c ****                     break;
 200:../../tmk_core/common/action.c ****             }
 201:../../tmk_core/common/action.c ****             break;
 202:../../tmk_core/common/action.c **** #endif
 203:../../tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 204:../../tmk_core/common/action.c ****         /* Mouse key */
 205:../../tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 206:../../tmk_core/common/action.c ****             if (event.pressed) {
 207:../../tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 208:../../tmk_core/common/action.c ****                 mousekey_send();
 209:../../tmk_core/common/action.c ****             } else {
 210:../../tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 211:../../tmk_core/common/action.c ****                 mousekey_send();
 212:../../tmk_core/common/action.c ****             }
 213:../../tmk_core/common/action.c ****             break;
 214:../../tmk_core/common/action.c **** #endif
 215:../../tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 216:../../tmk_core/common/action.c ****         case ACT_LAYER:
 217:../../tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 218:../../tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 219:../../tmk_core/common/action.c ****                 if (!event.pressed) {
 220:../../tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 221:../../tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 222:../../tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 223:../../tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 224:../../tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 225:../../tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 226:../../tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 227:../../tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 228:../../tmk_core/common/action.c ****                     }
 229:../../tmk_core/common/action.c ****                 }
 230:../../tmk_core/common/action.c ****             } else {
 231:../../tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 232:../../tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 233:../../tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 234:../../tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 235:../../tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 236:../../tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 237:../../tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 238:../../tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 239:../../tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 240:../../tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 241:../../tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 242:../../tmk_core/common/action.c ****                     }
 243:../../tmk_core/common/action.c ****                 }
 244:../../tmk_core/common/action.c ****             }
 245:../../tmk_core/common/action.c ****             break;
 246:../../tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 247:../../tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 248:../../tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 249:../../tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 250:../../tmk_core/common/action.c ****                 case 0xc0 ... 0xdf:
 251:../../tmk_core/common/action.c ****                     /* layer On/Off with modifiers */
 252:../../tmk_core/common/action.c ****                     if (event.pressed) {
 253:../../tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 254:../../tmk_core/common/action.c ****                         register_mods((action.layer_tap.code & 0x10) ?
 255:../../tmk_core/common/action.c ****                                 (action.layer_tap.code & 0x0f) << 4 :
 256:../../tmk_core/common/action.c ****                                 (action.layer_tap.code & 0x0f));
 257:../../tmk_core/common/action.c ****                     } else {
 258:../../tmk_core/common/action.c ****                         layer_off(action.layer_tap.val);
 259:../../tmk_core/common/action.c ****                         unregister_mods((action.layer_tap.code & 0x10) ?
 260:../../tmk_core/common/action.c ****                                 (action.layer_tap.code & 0x0f) << 4 :
 261:../../tmk_core/common/action.c ****                                 (action.layer_tap.code & 0x0f));
 262:../../tmk_core/common/action.c ****                     }
 263:../../tmk_core/common/action.c ****                     break;
 264:../../tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 265:../../tmk_core/common/action.c ****                     /* tap toggle */
 266:../../tmk_core/common/action.c ****                     if (event.pressed) {
 267:../../tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 268:../../tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 269:../../tmk_core/common/action.c ****                         }
 270:../../tmk_core/common/action.c ****                     } else {
 271:../../tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 272:../../tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 273:../../tmk_core/common/action.c ****                         }
 274:../../tmk_core/common/action.c ****                     }
 275:../../tmk_core/common/action.c ****                     break;
 276:../../tmk_core/common/action.c ****                 case OP_ON_OFF:
 277:../../tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 278:../../tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 279:../../tmk_core/common/action.c ****                     break;
 280:../../tmk_core/common/action.c ****                 case OP_OFF_ON:
 281:../../tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) :
 282:../../tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 283:../../tmk_core/common/action.c ****                     break;
 284:../../tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 285:../../tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 286:../../tmk_core/common/action.c ****                                     layer_clear();
 287:../../tmk_core/common/action.c ****                     break;
 288:../../tmk_core/common/action.c ****                 default:
 289:../../tmk_core/common/action.c ****                     /* tap key */
 290:../../tmk_core/common/action.c ****                     if (event.pressed) {
 291:../../tmk_core/common/action.c ****                         if (tap_count > 0) {
 292:../../tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 293:../../tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 294:../../tmk_core/common/action.c ****                         } else {
 295:../../tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 296:../../tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 297:../../tmk_core/common/action.c ****                         }
 298:../../tmk_core/common/action.c ****                     } else {
 299:../../tmk_core/common/action.c ****                         if (tap_count > 0) {
 300:../../tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 301:../../tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 302:../../tmk_core/common/action.c ****                         } else {
 303:../../tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 304:../../tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 305:../../tmk_core/common/action.c ****                         }
 306:../../tmk_core/common/action.c ****                     }
 307:../../tmk_core/common/action.c ****                     break;
 308:../../tmk_core/common/action.c ****             }
 309:../../tmk_core/common/action.c ****             break;
 310:../../tmk_core/common/action.c ****     #endif
 311:../../tmk_core/common/action.c **** #endif
 312:../../tmk_core/common/action.c ****         /* Extentions */
 313:../../tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 314:../../tmk_core/common/action.c ****         case ACT_MACRO:
 315:../../tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 316:../../tmk_core/common/action.c ****             break;
 317:../../tmk_core/common/action.c **** #endif
 318:../../tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
 319:../../tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 320:../../tmk_core/common/action.c ****             if (!event.pressed) {
 321:../../tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 322:../../tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 323:../../tmk_core/common/action.c ****                         backlight_increase();
 324:../../tmk_core/common/action.c ****                         break;
 325:../../tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 326:../../tmk_core/common/action.c ****                         backlight_decrease();
 327:../../tmk_core/common/action.c ****                         break;
 328:../../tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 329:../../tmk_core/common/action.c ****                         backlight_toggle();
 330:../../tmk_core/common/action.c ****                         break;
 331:../../tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 332:../../tmk_core/common/action.c ****                         backlight_step();
 333:../../tmk_core/common/action.c ****                         break;
 334:../../tmk_core/common/action.c ****                     case BACKLIGHT_LEVEL:
 335:../../tmk_core/common/action.c ****                         backlight_level(action.backlight.level);
 336:../../tmk_core/common/action.c ****                         break;
 337:../../tmk_core/common/action.c ****                 }
 338:../../tmk_core/common/action.c ****             }
 339:../../tmk_core/common/action.c ****             break;
 340:../../tmk_core/common/action.c **** #endif
 341:../../tmk_core/common/action.c ****         case ACT_COMMAND:
 342:../../tmk_core/common/action.c ****             break;
 343:../../tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 344:../../tmk_core/common/action.c ****         case ACT_FUNCTION:
 345:../../tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 346:../../tmk_core/common/action.c ****             break;
 347:../../tmk_core/common/action.c **** #endif
 348:../../tmk_core/common/action.c ****         default:
 349:../../tmk_core/common/action.c ****             break;
 350:../../tmk_core/common/action.c ****     }
 351:../../tmk_core/common/action.c **** }
 352:../../tmk_core/common/action.c **** 
 353:../../tmk_core/common/action.c **** 
 354:../../tmk_core/common/action.c **** 
 355:../../tmk_core/common/action.c **** 
 356:../../tmk_core/common/action.c **** /*
 357:../../tmk_core/common/action.c ****  * Utilities for actions.
 358:../../tmk_core/common/action.c ****  */
 359:../../tmk_core/common/action.c **** void register_code(uint8_t code)
 360:../../tmk_core/common/action.c **** {
 131               		.loc 1 360 0
 132               		.cfi_startproc
 133               	.LVL7:
 134 0000 CF93      		push r28
 135               	.LCFI4:
 136               		.cfi_def_cfa_offset 3
 137               		.cfi_offset 28, -2
 138               	/* prologue: function */
 139               	/* frame size = 0 */
 140               	/* stack size = 1 */
 141               	.L__stack_usage = 1
 142 0002 C82F      		mov r28,r24
 361:../../tmk_core/common/action.c ****     if (code == KC_NO) {
 143               		.loc 1 361 0
 144 0004 8823      		tst r24
 145 0006 01F4      		brne .+2
 146 0008 00C0      		rjmp .L8
 362:../../tmk_core/common/action.c ****         return;
 363:../../tmk_core/common/action.c ****     }
 364:../../tmk_core/common/action.c **** 
 365:../../tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 366:../../tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 147               		.loc 1 366 0
 148 000a 8238      		cpi r24,lo8(-126)
 149 000c 01F4      		brne .L11
 367:../../tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 368:../../tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 369:../../tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK)) return;
 150               		.loc 1 369 0
 151 000e 0E94 0000 		call host_keyboard_leds
 152               	.LVL8:
 153 0012 81FD      		sbrc r24,1
 154 0014 00C0      		rjmp .L8
 370:../../tmk_core/common/action.c **** #endif
 371:../../tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 155               		.loc 1 371 0
 156 0016 89E3      		ldi r24,lo8(57)
 157 0018 0E94 0000 		call add_key
 158               	.LVL9:
 372:../../tmk_core/common/action.c ****         send_keyboard_report();
 159               		.loc 1 372 0
 160 001c 0E94 0000 		call send_keyboard_report
 161               	.LVL10:
 162               	.LBB18:
 163               	.LBB19:
 164               		.file 3 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165               		.loc 3 164 0
 166 0020 2FEF      		ldi r18,lo8(319999)
 167 0022 81EE      		ldi r24,hi8(319999)
 168 0024 94E0      		ldi r25,hlo8(319999)
 169 0026 2150      		1: subi r18,1
 170 0028 8040      		sbci r24,0
 171 002a 9040      		sbci r25,0
 172 002c 01F4      		brne 1b
 173 002e 00C0      		rjmp .
 174 0030 0000      		nop
 175               	.LBE19:
 176               	.LBE18:
 373:../../tmk_core/common/action.c ****         wait_ms(100);
 374:../../tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 177               		.loc 1 374 0
 178 0032 89E3      		ldi r24,lo8(57)
 179 0034 00C0      		rjmp .L43
 180               	.LVL11:
 181               	.L11:
 375:../../tmk_core/common/action.c ****         send_keyboard_report();
 376:../../tmk_core/common/action.c ****     }
 377:../../tmk_core/common/action.c **** 
 378:../../tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 182               		.loc 1 378 0
 183 0036 8338      		cpi r24,lo8(-125)
 184 0038 01F4      		brne .L13
 379:../../tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 380:../../tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_NUM_LOCK)) return;
 185               		.loc 1 380 0
 186 003a 0E94 0000 		call host_keyboard_leds
 187               	.LVL12:
 188 003e 80FD      		sbrc r24,0
 189 0040 00C0      		rjmp .L8
 381:../../tmk_core/common/action.c **** #endif
 382:../../tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 190               		.loc 1 382 0
 191 0042 83E5      		ldi r24,lo8(83)
 192 0044 0E94 0000 		call add_key
 193               	.LVL13:
 383:../../tmk_core/common/action.c ****         send_keyboard_report();
 194               		.loc 1 383 0
 195 0048 0E94 0000 		call send_keyboard_report
 196               	.LVL14:
 197               	.LBB20:
 198               	.LBB21:
 199               		.loc 3 164 0
 200 004c 2FEF      		ldi r18,lo8(319999)
 201 004e 81EE      		ldi r24,hi8(319999)
 202 0050 94E0      		ldi r25,hlo8(319999)
 203 0052 2150      		1: subi r18,1
 204 0054 8040      		sbci r24,0
 205 0056 9040      		sbci r25,0
 206 0058 01F4      		brne 1b
 207 005a 00C0      		rjmp .
 208 005c 0000      		nop
 209               	.LBE21:
 210               	.LBE20:
 384:../../tmk_core/common/action.c ****         wait_ms(100);
 385:../../tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 211               		.loc 1 385 0
 212 005e 83E5      		ldi r24,lo8(83)
 213               	.LVL15:
 214               	.L43:
 215 0060 0E94 0000 		call del_key
 216               	.LVL16:
 217               	.L44:
 218               	/* epilogue start */
 386:../../tmk_core/common/action.c ****         send_keyboard_report();
 387:../../tmk_core/common/action.c ****     }
 388:../../tmk_core/common/action.c **** 
 389:../../tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 390:../../tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 391:../../tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK)) return;
 392:../../tmk_core/common/action.c **** #endif
 393:../../tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 394:../../tmk_core/common/action.c ****         send_keyboard_report();
 395:../../tmk_core/common/action.c ****         wait_ms(100);
 396:../../tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 397:../../tmk_core/common/action.c ****         send_keyboard_report();
 398:../../tmk_core/common/action.c ****     }
 399:../../tmk_core/common/action.c **** #endif
 400:../../tmk_core/common/action.c **** 
 401:../../tmk_core/common/action.c ****     else if IS_KEY(code) {
 402:../../tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 403:../../tmk_core/common/action.c ****         if (command_proc(code)) return;
 404:../../tmk_core/common/action.c **** 
 405:../../tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 406:../../tmk_core/common/action.c **** /* TODO: remove
 407:../../tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 408:../../tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 409:../../tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 410:../../tmk_core/common/action.c **** 
 411:../../tmk_core/common/action.c ****             add_key(code);
 412:../../tmk_core/common/action.c ****             send_keyboard_report();
 413:../../tmk_core/common/action.c **** 
 414:../../tmk_core/common/action.c ****             set_mods(tmp_mods);
 415:../../tmk_core/common/action.c ****             send_keyboard_report();
 416:../../tmk_core/common/action.c ****             oneshot_cancel();
 417:../../tmk_core/common/action.c ****         } else 
 418:../../tmk_core/common/action.c **** */
 419:../../tmk_core/common/action.c **** #endif
 420:../../tmk_core/common/action.c ****         {
 421:../../tmk_core/common/action.c ****             add_key(code);
 422:../../tmk_core/common/action.c ****             send_keyboard_report();
 423:../../tmk_core/common/action.c ****         }
 424:../../tmk_core/common/action.c ****     }
 425:../../tmk_core/common/action.c ****     else if IS_MOD(code) {
 426:../../tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 427:../../tmk_core/common/action.c ****         send_keyboard_report();
 428:../../tmk_core/common/action.c ****     }
 429:../../tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 430:../../tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 431:../../tmk_core/common/action.c ****     }
 432:../../tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 434:../../tmk_core/common/action.c ****     }
 435:../../tmk_core/common/action.c **** }
 219               		.loc 1 435 0
 220 0064 CF91      		pop r28
 386:../../tmk_core/common/action.c ****         send_keyboard_report();
 221               		.loc 1 386 0
 222 0066 0C94 0000 		jmp send_keyboard_report
 223               	.LVL17:
 224               	.L13:
 389:../../tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 225               		.loc 1 389 0
 226 006a 8438      		cpi r24,lo8(-124)
 227 006c 01F4      		brne .L14
 391:../../tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK)) return;
 228               		.loc 1 391 0
 229 006e 0E94 0000 		call host_keyboard_leds
 230               	.LVL18:
 231 0072 82FD      		sbrc r24,2
 232 0074 00C0      		rjmp .L8
 393:../../tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 233               		.loc 1 393 0
 234 0076 87E4      		ldi r24,lo8(71)
 235 0078 0E94 0000 		call add_key
 236               	.LVL19:
 394:../../tmk_core/common/action.c ****         send_keyboard_report();
 237               		.loc 1 394 0
 238 007c 0E94 0000 		call send_keyboard_report
 239               	.LVL20:
 240               	.LBB22:
 241               	.LBB23:
 242               		.loc 3 164 0
 243 0080 2FEF      		ldi r18,lo8(319999)
 244 0082 81EE      		ldi r24,hi8(319999)
 245 0084 94E0      		ldi r25,hlo8(319999)
 246 0086 2150      		1: subi r18,1
 247 0088 8040      		sbci r24,0
 248 008a 9040      		sbci r25,0
 249 008c 01F4      		brne 1b
 250 008e 00C0      		rjmp .
 251 0090 0000      		nop
 252               	.LBE23:
 253               	.LBE22:
 396:../../tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 254               		.loc 1 396 0
 255 0092 87E4      		ldi r24,lo8(71)
 256 0094 00C0      		rjmp .L43
 257               	.LVL21:
 258               	.L14:
 401:../../tmk_core/common/action.c ****     else if IS_KEY(code) {
 259               		.loc 1 401 0
 260 0096 8CEF      		ldi r24,lo8(-4)
 261               	.LVL22:
 262 0098 8C0F      		add r24,r28
 263 009a 813A      		cpi r24,lo8(-95)
 264 009c 00F4      		brsh .L15
 403:../../tmk_core/common/action.c ****         if (command_proc(code)) return;
 265               		.loc 1 403 0
 266 009e 8C2F      		mov r24,r28
 267 00a0 0E94 0000 		call command_proc
 268               	.LVL23:
 269 00a4 8111      		cpse r24,__zero_reg__
 270 00a6 00C0      		rjmp .L8
 421:../../tmk_core/common/action.c ****             add_key(code);
 271               		.loc 1 421 0
 272 00a8 8C2F      		mov r24,r28
 273 00aa 0E94 0000 		call add_key
 274               	.LVL24:
 275 00ae 00C0      		rjmp .L44
 276               	.L15:
 425:../../tmk_core/common/action.c ****     else if IS_MOD(code) {
 277               		.loc 1 425 0
 278 00b0 80E2      		ldi r24,lo8(32)
 279 00b2 8C0F      		add r24,r28
 280 00b4 8830      		cpi r24,lo8(8)
 281 00b6 00F4      		brsh .L16
 426:../../tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 282               		.loc 1 426 0
 283 00b8 C770      		andi r28,lo8(7)
 284               	.LVL25:
 285 00ba 81E0      		ldi r24,lo8(1)
 286 00bc 00C0      		rjmp 2f
 287               		1:
 288 00be 880F      		lsl r24
 289               		2:
 290 00c0 CA95      		dec r28
 291 00c2 02F4      		brpl 1b
 292 00c4 0E94 0000 		call add_mods
 293               	.LVL26:
 294 00c8 00C0      		rjmp .L44
 295               	.LVL27:
 296               	.L16:
 429:../../tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 297               		.loc 1 429 0
 298 00ca 8BE5      		ldi r24,lo8(91)
 299 00cc 8C0F      		add r24,r28
 300 00ce 8330      		cpi r24,lo8(3)
 301 00d0 00F4      		brsh .L17
 430:../../tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 302               		.loc 1 430 0
 303 00d2 C53A      		cpi r28,lo8(-91)
 304 00d4 01F0      		breq .L20
 430:../../tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 305               		.loc 1 430 0 is_stmt 0 discriminator 1
 306 00d6 C63A      		cpi r28,lo8(-90)
 307 00d8 01F4      		brne .L21
 430:../../tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 308               		.loc 1 430 0
 309 00da 82E8      		ldi r24,lo8(-126)
 310 00dc 90E0      		ldi r25,0
 311 00de 00C0      		rjmp .L18
 312               	.L20:
 313 00e0 81E8      		ldi r24,lo8(-127)
 314 00e2 90E0      		ldi r25,0
 315 00e4 00C0      		rjmp .L18
 316               	.L21:
 317 00e6 83E8      		ldi r24,lo8(-125)
 318 00e8 90E0      		ldi r25,0
 319               	.L18:
 320               	/* epilogue start */
 321               		.loc 1 435 0 is_stmt 1 discriminator 4
 322 00ea CF91      		pop r28
 323               	.LVL28:
 430:../../tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 324               		.loc 1 430 0 discriminator 4
 325 00ec 0C94 0000 		jmp host_system_send
 326               	.LVL29:
 327               	.L17:
 432:../../tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 328               		.loc 1 432 0
 329 00f0 88E5      		ldi r24,lo8(88)
 330 00f2 8C0F      		add r24,r28
 331 00f4 8531      		cpi r24,lo8(21)
 332 00f6 00F0      		brlo .+2
 333 00f8 00C0      		rjmp .L8
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 334               		.loc 1 433 0
 335 00fa C83A      		cpi r28,lo8(-88)
 336 00fc 01F0      		breq .L22
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 337               		.loc 1 433 0 is_stmt 0 discriminator 1
 338 00fe C93A      		cpi r28,lo8(-87)
 339 0100 01F0      		breq .L23
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 340               		.loc 1 433 0 discriminator 3
 341 0102 CA3A      		cpi r28,lo8(-86)
 342 0104 01F0      		breq .L24
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 343               		.loc 1 433 0 discriminator 5
 344 0106 CB3A      		cpi r28,lo8(-85)
 345 0108 01F0      		breq .L25
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 346               		.loc 1 433 0 discriminator 7
 347 010a CC3A      		cpi r28,lo8(-84)
 348 010c 01F0      		breq .L26
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 349               		.loc 1 433 0 discriminator 9
 350 010e CD3A      		cpi r28,lo8(-83)
 351 0110 01F0      		breq .L27
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 352               		.loc 1 433 0 discriminator 11
 353 0112 CE3A      		cpi r28,lo8(-82)
 354 0114 01F0      		breq .L28
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 355               		.loc 1 433 0 discriminator 13
 356 0116 CF3A      		cpi r28,lo8(-81)
 357 0118 01F0      		breq .L29
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 358               		.loc 1 433 0 discriminator 15
 359 011a C13B      		cpi r28,lo8(-79)
 360 011c 01F0      		breq .L30
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 361               		.loc 1 433 0 discriminator 17
 362 011e C03B      		cpi r28,lo8(-80)
 363 0120 01F0      		breq .L31
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 364               		.loc 1 433 0 discriminator 19
 365 0122 C23B      		cpi r28,lo8(-78)
 366 0124 01F0      		breq .L32
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 367               		.loc 1 433 0 discriminator 21
 368 0126 C33B      		cpi r28,lo8(-77)
 369 0128 01F0      		breq .L33
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 370               		.loc 1 433 0 discriminator 23
 371 012a C43B      		cpi r28,lo8(-76)
 372 012c 01F0      		breq .L34
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 373               		.loc 1 433 0 discriminator 25
 374 012e C53B      		cpi r28,lo8(-75)
 375 0130 01F0      		breq .L35
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 376               		.loc 1 433 0 discriminator 27
 377 0132 C63B      		cpi r28,lo8(-74)
 378 0134 01F0      		breq .L36
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 379               		.loc 1 433 0 discriminator 29
 380 0136 C73B      		cpi r28,lo8(-73)
 381 0138 01F0      		breq .L37
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 382               		.loc 1 433 0 discriminator 31
 383 013a C83B      		cpi r28,lo8(-72)
 384 013c 01F0      		breq .L38
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 385               		.loc 1 433 0 discriminator 33
 386 013e C93B      		cpi r28,lo8(-71)
 387 0140 01F0      		breq .L39
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 388               		.loc 1 433 0 discriminator 35
 389 0142 CA3B      		cpi r28,lo8(-70)
 390 0144 01F0      		breq .L40
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 391               		.loc 1 433 0 discriminator 37
 392 0146 CB3B      		cpi r28,lo8(-69)
 393 0148 01F0      		breq .L41
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 394               		.loc 1 433 0 discriminator 39
 395 014a CC3B      		cpi r28,lo8(-68)
 396 014c 01F0      		breq .+2
 397 014e 00C0      		rjmp .L42
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 398               		.loc 1 433 0
 399 0150 8AE2      		ldi r24,lo8(42)
 400 0152 92E0      		ldi r25,lo8(2)
 401 0154 00C0      		rjmp .L19
 402               	.L22:
 403 0156 82EE      		ldi r24,lo8(-30)
 404 0158 90E0      		ldi r25,0
 405 015a 00C0      		rjmp .L19
 406               	.L23:
 407 015c 89EE      		ldi r24,lo8(-23)
 408 015e 90E0      		ldi r25,0
 409 0160 00C0      		rjmp .L19
 410               	.L24:
 411 0162 8AEE      		ldi r24,lo8(-22)
 412 0164 90E0      		ldi r25,0
 413 0166 00C0      		rjmp .L19
 414               	.L25:
 415 0168 85EB      		ldi r24,lo8(-75)
 416 016a 90E0      		ldi r25,0
 417 016c 00C0      		rjmp .L19
 418               	.L26:
 419 016e 86EB      		ldi r24,lo8(-74)
 420 0170 90E0      		ldi r25,0
 421 0172 00C0      		rjmp .L19
 422               	.L27:
 423 0174 83EB      		ldi r24,lo8(-77)
 424 0176 90E0      		ldi r25,0
 425 0178 00C0      		rjmp .L19
 426               	.L28:
 427 017a 84EB      		ldi r24,lo8(-76)
 428 017c 90E0      		ldi r25,0
 429 017e 00C0      		rjmp .L19
 430               	.L29:
 431 0180 87EB      		ldi r24,lo8(-73)
 432 0182 90E0      		ldi r25,0
 433 0184 00C0      		rjmp .L19
 434               	.L30:
 435 0186 8CEC      		ldi r24,lo8(-52)
 436 0188 90E0      		ldi r25,0
 437 018a 00C0      		rjmp .L19
 438               	.L31:
 439 018c 8DEC      		ldi r24,lo8(-51)
 440 018e 90E0      		ldi r25,0
 441 0190 00C0      		rjmp .L19
 442               	.L32:
 443 0192 83E8      		ldi r24,lo8(-125)
 444 0194 91E0      		ldi r25,lo8(1)
 445 0196 00C0      		rjmp .L19
 446               	.L33:
 447 0198 8AE8      		ldi r24,lo8(-118)
 448 019a 91E0      		ldi r25,lo8(1)
 449 019c 00C0      		rjmp .L19
 450               	.L34:
 451 019e 82E9      		ldi r24,lo8(-110)
 452 01a0 91E0      		ldi r25,lo8(1)
 453 01a2 00C0      		rjmp .L19
 454               	.L35:
 455 01a4 84E9      		ldi r24,lo8(-108)
 456 01a6 91E0      		ldi r25,lo8(1)
 457 01a8 00C0      		rjmp .L19
 458               	.L36:
 459 01aa 81E2      		ldi r24,lo8(33)
 460 01ac 92E0      		ldi r25,lo8(2)
 461 01ae 00C0      		rjmp .L19
 462               	.L37:
 463 01b0 83E2      		ldi r24,lo8(35)
 464 01b2 92E0      		ldi r25,lo8(2)
 465 01b4 00C0      		rjmp .L19
 466               	.L38:
 467 01b6 84E2      		ldi r24,lo8(36)
 468 01b8 92E0      		ldi r25,lo8(2)
 469 01ba 00C0      		rjmp .L19
 470               	.L39:
 471 01bc 85E2      		ldi r24,lo8(37)
 472 01be 92E0      		ldi r25,lo8(2)
 473 01c0 00C0      		rjmp .L19
 474               	.L40:
 475 01c2 86E2      		ldi r24,lo8(38)
 476 01c4 92E0      		ldi r25,lo8(2)
 477 01c6 00C0      		rjmp .L19
 478               	.L41:
 479 01c8 87E2      		ldi r24,lo8(39)
 480 01ca 92E0      		ldi r25,lo8(2)
 481 01cc 00C0      		rjmp .L19
 482               	.L42:
 483 01ce 80E0      		ldi r24,0
 484 01d0 90E0      		ldi r25,0
 485               	.L19:
 486               	/* epilogue start */
 487               		.loc 1 435 0 is_stmt 1 discriminator 43
 488 01d2 CF91      		pop r28
 489               	.LVL30:
 433:../../tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 490               		.loc 1 433 0 discriminator 43
 491 01d4 0C94 0000 		jmp host_consumer_send
 492               	.LVL31:
 493               	.L8:
 494               	/* epilogue start */
 495               		.loc 1 435 0
 496 01d8 CF91      		pop r28
 497               	.LVL32:
 498 01da 0895      		ret
 499               		.cfi_endproc
 500               	.LFE12:
 502               		.section	.text.unregister_code,"ax",@progbits
 503               	.global	unregister_code
 505               	unregister_code:
 506               	.LFB13:
 436:../../tmk_core/common/action.c **** 
 437:../../tmk_core/common/action.c **** void unregister_code(uint8_t code)
 438:../../tmk_core/common/action.c **** {
 507               		.loc 1 438 0
 508               		.cfi_startproc
 509               	.LVL33:
 510               	/* prologue: function */
 511               	/* frame size = 0 */
 512               	/* stack size = 0 */
 513               	.L__stack_usage = 0
 439:../../tmk_core/common/action.c ****     if (code == KC_NO) {
 514               		.loc 1 439 0
 515 0000 8823      		tst r24
 516 0002 01F4      		brne .+2
 517 0004 00C0      		rjmp .L45
 440:../../tmk_core/common/action.c ****         return;
 441:../../tmk_core/common/action.c ****     }
 442:../../tmk_core/common/action.c **** 
 443:../../tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 444:../../tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 518               		.loc 1 444 0
 519 0006 8238      		cpi r24,lo8(-126)
 520 0008 01F4      		brne .L48
 445:../../tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 446:../../tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 447:../../tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK))) return;
 521               		.loc 1 447 0
 522 000a 0E94 0000 		call host_keyboard_leds
 523               	.LVL34:
 524 000e 81FF      		sbrs r24,1
 525 0010 00C0      		rjmp .L45
 448:../../tmk_core/common/action.c **** #endif
 449:../../tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 526               		.loc 1 449 0
 527 0012 89E3      		ldi r24,lo8(57)
 528 0014 0E94 0000 		call add_key
 529               	.LVL35:
 450:../../tmk_core/common/action.c ****         send_keyboard_report();
 530               		.loc 1 450 0
 531 0018 0E94 0000 		call send_keyboard_report
 532               	.LVL36:
 533               	.LBB24:
 534               	.LBB25:
 535               		.loc 3 164 0
 536 001c 2FEF      		ldi r18,lo8(319999)
 537 001e 81EE      		ldi r24,hi8(319999)
 538 0020 94E0      		ldi r25,hlo8(319999)
 539 0022 2150      		1: subi r18,1
 540 0024 8040      		sbci r24,0
 541 0026 9040      		sbci r25,0
 542 0028 01F4      		brne 1b
 543 002a 00C0      		rjmp .
 544 002c 0000      		nop
 545               	.LBE25:
 546               	.LBE24:
 451:../../tmk_core/common/action.c ****         wait_ms(100);
 452:../../tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 547               		.loc 1 452 0
 548 002e 89E3      		ldi r24,lo8(57)
 549 0030 00C0      		rjmp .L64
 550               	.LVL37:
 551               	.L48:
 453:../../tmk_core/common/action.c ****         send_keyboard_report();
 454:../../tmk_core/common/action.c ****     }
 455:../../tmk_core/common/action.c **** 
 456:../../tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 552               		.loc 1 456 0
 553 0032 8338      		cpi r24,lo8(-125)
 554 0034 01F4      		brne .L50
 457:../../tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 458:../../tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_NUM_LOCK))) return;
 555               		.loc 1 458 0
 556 0036 0E94 0000 		call host_keyboard_leds
 557               	.LVL38:
 558 003a 80FF      		sbrs r24,0
 559 003c 00C0      		rjmp .L45
 459:../../tmk_core/common/action.c **** #endif
 460:../../tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 560               		.loc 1 460 0
 561 003e 83E5      		ldi r24,lo8(83)
 562 0040 0E94 0000 		call add_key
 563               	.LVL39:
 461:../../tmk_core/common/action.c ****         send_keyboard_report();
 564               		.loc 1 461 0
 565 0044 0E94 0000 		call send_keyboard_report
 566               	.LVL40:
 567               	.LBB26:
 568               	.LBB27:
 569               		.loc 3 164 0
 570 0048 2FEF      		ldi r18,lo8(319999)
 571 004a 81EE      		ldi r24,hi8(319999)
 572 004c 94E0      		ldi r25,hlo8(319999)
 573 004e 2150      		1: subi r18,1
 574 0050 8040      		sbci r24,0
 575 0052 9040      		sbci r25,0
 576 0054 01F4      		brne 1b
 577 0056 00C0      		rjmp .
 578 0058 0000      		nop
 579               	.LBE27:
 580               	.LBE26:
 462:../../tmk_core/common/action.c ****         wait_ms(100);
 463:../../tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 581               		.loc 1 463 0
 582 005a 83E5      		ldi r24,lo8(83)
 583               	.LVL41:
 584               	.L64:
 585 005c 0E94 0000 		call del_key
 586               	.LVL42:
 587               	.L65:
 464:../../tmk_core/common/action.c ****         send_keyboard_report();
 588               		.loc 1 464 0
 589 0060 0C94 0000 		jmp send_keyboard_report
 590               	.LVL43:
 591               	.L50:
 465:../../tmk_core/common/action.c ****     }
 466:../../tmk_core/common/action.c **** 
 467:../../tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 592               		.loc 1 467 0
 593 0064 8438      		cpi r24,lo8(-124)
 594 0066 01F4      		brne .L51
 468:../../tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 469:../../tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK))) return;
 595               		.loc 1 469 0
 596 0068 0E94 0000 		call host_keyboard_leds
 597               	.LVL44:
 598 006c 82FF      		sbrs r24,2
 599 006e 00C0      		rjmp .L45
 470:../../tmk_core/common/action.c **** #endif
 471:../../tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 600               		.loc 1 471 0
 601 0070 87E4      		ldi r24,lo8(71)
 602 0072 0E94 0000 		call add_key
 603               	.LVL45:
 472:../../tmk_core/common/action.c ****         send_keyboard_report();
 604               		.loc 1 472 0
 605 0076 0E94 0000 		call send_keyboard_report
 606               	.LVL46:
 607               	.LBB28:
 608               	.LBB29:
 609               		.loc 3 164 0
 610 007a 2FEF      		ldi r18,lo8(319999)
 611 007c 81EE      		ldi r24,hi8(319999)
 612 007e 94E0      		ldi r25,hlo8(319999)
 613 0080 2150      		1: subi r18,1
 614 0082 8040      		sbci r24,0
 615 0084 9040      		sbci r25,0
 616 0086 01F4      		brne 1b
 617 0088 00C0      		rjmp .
 618 008a 0000      		nop
 619               	.LBE29:
 620               	.LBE28:
 473:../../tmk_core/common/action.c ****         wait_ms(100);
 474:../../tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 621               		.loc 1 474 0
 622 008c 87E4      		ldi r24,lo8(71)
 623 008e 00C0      		rjmp .L64
 624               	.LVL47:
 625               	.L51:
 475:../../tmk_core/common/action.c ****         send_keyboard_report();
 476:../../tmk_core/common/action.c ****     }
 477:../../tmk_core/common/action.c **** #endif
 478:../../tmk_core/common/action.c **** 
 479:../../tmk_core/common/action.c ****     else if IS_KEY(code) {
 626               		.loc 1 479 0
 627 0090 9CEF      		ldi r25,lo8(-4)
 628 0092 980F      		add r25,r24
 629 0094 913A      		cpi r25,lo8(-95)
 630 0096 00F0      		brlo .L64
 480:../../tmk_core/common/action.c ****         del_key(code);
 481:../../tmk_core/common/action.c ****         send_keyboard_report();
 482:../../tmk_core/common/action.c ****     }
 483:../../tmk_core/common/action.c ****     else if IS_MOD(code) {
 631               		.loc 1 483 0
 632 0098 90E2      		ldi r25,lo8(32)
 633 009a 980F      		add r25,r24
 634 009c 9830      		cpi r25,lo8(8)
 635 009e 00F4      		brsh .L53
 484:../../tmk_core/common/action.c ****         del_mods(MOD_BIT(code));
 636               		.loc 1 484 0
 637 00a0 8770      		andi r24,lo8(7)
 638               	.LVL48:
 639 00a2 91E0      		ldi r25,lo8(1)
 640 00a4 00C0      		rjmp 2f
 641               		1:
 642 00a6 990F      		lsl r25
 643               		2:
 644 00a8 8A95      		dec r24
 645 00aa 02F4      		brpl 1b
 646 00ac 892F      		mov r24,r25
 647 00ae 0E94 0000 		call del_mods
 648               	.LVL49:
 649 00b2 00C0      		rjmp .L65
 650               	.LVL50:
 651               	.L53:
 485:../../tmk_core/common/action.c ****         send_keyboard_report();
 486:../../tmk_core/common/action.c ****     }
 487:../../tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 652               		.loc 1 487 0
 653 00b4 9BE5      		ldi r25,lo8(91)
 654 00b6 980F      		add r25,r24
 655 00b8 9330      		cpi r25,lo8(3)
 656 00ba 00F4      		brsh .L54
 488:../../tmk_core/common/action.c ****         host_system_send(0);
 657               		.loc 1 488 0
 658 00bc 80E0      		ldi r24,0
 659 00be 90E0      		ldi r25,0
 660               	.LVL51:
 661 00c0 0C94 0000 		jmp host_system_send
 662               	.LVL52:
 663               	.L54:
 489:../../tmk_core/common/action.c ****     }
 490:../../tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 664               		.loc 1 490 0
 665 00c4 885A      		subi r24,lo8(-(88))
 666               	.LVL53:
 667 00c6 8531      		cpi r24,lo8(21)
 668 00c8 00F4      		brsh .L45
 491:../../tmk_core/common/action.c ****         host_consumer_send(0);
 669               		.loc 1 491 0
 670 00ca 80E0      		ldi r24,0
 671 00cc 90E0      		ldi r25,0
 672               	.LVL54:
 673 00ce 0C94 0000 		jmp host_consumer_send
 674               	.LVL55:
 675               	.L45:
 676 00d2 0895      		ret
 677               		.cfi_endproc
 678               	.LFE13:
 680               		.section	.text.register_mods,"ax",@progbits
 681               	.global	register_mods
 683               	register_mods:
 684               	.LFB14:
 492:../../tmk_core/common/action.c ****     }
 493:../../tmk_core/common/action.c **** }
 494:../../tmk_core/common/action.c **** 
 495:../../tmk_core/common/action.c **** void register_mods(uint8_t mods)
 496:../../tmk_core/common/action.c **** {
 685               		.loc 1 496 0
 686               		.cfi_startproc
 687               	.LVL56:
 688               	/* prologue: function */
 689               	/* frame size = 0 */
 690               	/* stack size = 0 */
 691               	.L__stack_usage = 0
 497:../../tmk_core/common/action.c ****     if (mods) {
 692               		.loc 1 497 0
 693 0000 8823      		tst r24
 694 0002 01F0      		breq .L66
 498:../../tmk_core/common/action.c ****         add_mods(mods);
 695               		.loc 1 498 0
 696 0004 0E94 0000 		call add_mods
 697               	.LVL57:
 499:../../tmk_core/common/action.c ****         send_keyboard_report();
 698               		.loc 1 499 0
 699 0008 0C94 0000 		jmp send_keyboard_report
 700               	.LVL58:
 701               	.L66:
 702 000c 0895      		ret
 703               		.cfi_endproc
 704               	.LFE14:
 706               		.section	.text.unregister_mods,"ax",@progbits
 707               	.global	unregister_mods
 709               	unregister_mods:
 710               	.LFB15:
 500:../../tmk_core/common/action.c ****     }
 501:../../tmk_core/common/action.c **** }
 502:../../tmk_core/common/action.c **** 
 503:../../tmk_core/common/action.c **** void unregister_mods(uint8_t mods)
 504:../../tmk_core/common/action.c **** {
 711               		.loc 1 504 0
 712               		.cfi_startproc
 713               	.LVL59:
 714               	/* prologue: function */
 715               	/* frame size = 0 */
 716               	/* stack size = 0 */
 717               	.L__stack_usage = 0
 505:../../tmk_core/common/action.c ****     if (mods) {
 718               		.loc 1 505 0
 719 0000 8823      		tst r24
 720 0002 01F0      		breq .L68
 506:../../tmk_core/common/action.c ****         del_mods(mods);
 721               		.loc 1 506 0
 722 0004 0E94 0000 		call del_mods
 723               	.LVL60:
 507:../../tmk_core/common/action.c ****         send_keyboard_report();
 724               		.loc 1 507 0
 725 0008 0C94 0000 		jmp send_keyboard_report
 726               	.LVL61:
 727               	.L68:
 728 000c 0895      		ret
 729               		.cfi_endproc
 730               	.LFE15:
 732               		.section	.text.process_action,"ax",@progbits
 733               	.global	process_action
 735               	process_action:
 736               	.LFB11:
  60:../../tmk_core/common/action.c **** {
 737               		.loc 1 60 0
 738               		.cfi_startproc
 739               	.LVL62:
 740 0000 CF92      		push r12
 741               	.LCFI5:
 742               		.cfi_def_cfa_offset 3
 743               		.cfi_offset 12, -2
 744 0002 DF92      		push r13
 745               	.LCFI6:
 746               		.cfi_def_cfa_offset 4
 747               		.cfi_offset 13, -3
 748 0004 EF92      		push r14
 749               	.LCFI7:
 750               		.cfi_def_cfa_offset 5
 751               		.cfi_offset 14, -4
 752 0006 FF92      		push r15
 753               	.LCFI8:
 754               		.cfi_def_cfa_offset 6
 755               		.cfi_offset 15, -5
 756 0008 0F93      		push r16
 757               	.LCFI9:
 758               		.cfi_def_cfa_offset 7
 759               		.cfi_offset 16, -6
 760 000a 1F93      		push r17
 761               	.LCFI10:
 762               		.cfi_def_cfa_offset 8
 763               		.cfi_offset 17, -7
 764 000c CF93      		push r28
 765               	.LCFI11:
 766               		.cfi_def_cfa_offset 9
 767               		.cfi_offset 28, -8
 768 000e DF93      		push r29
 769               	.LCFI12:
 770               		.cfi_def_cfa_offset 10
 771               		.cfi_offset 29, -9
 772 0010 CDB7      		in r28,__SP_L__
 773 0012 DEB7      		in r29,__SP_H__
 774               	.LCFI13:
 775               		.cfi_def_cfa_register 28
 776 0014 2897      		sbiw r28,8
 777               	.LCFI14:
 778               		.cfi_def_cfa_offset 18
 779 0016 0FB6      		in __tmp_reg__,__SREG__
 780 0018 F894      		cli
 781 001a DEBF      		out __SP_H__,r29
 782 001c 0FBE      		out __SREG__,__tmp_reg__
 783 001e CDBF      		out __SP_L__,r28
 784               	/* prologue: function */
 785               	/* frame size = 8 */
 786               	/* stack size = 16 */
 787               	.L__stack_usage = 16
 788 0020 8C01      		movw r16,r24
  61:../../tmk_core/common/action.c ****     keyevent_t event = record->event;
 789               		.loc 1 61 0
 790 0022 85E0      		ldi r24,lo8(5)
 791               	.LVL63:
 792 0024 F801      		movw r30,r16
 793 0026 DE01      		movw r26,r28
 794 0028 1196      		adiw r26,1
 795               		0:
 796 002a 0190      		ld r0,Z+
 797 002c 0D92      		st X+,r0
 798 002e 8A95      		dec r24
 799 0030 01F4      		brne 0b
 800 0032 F801      		movw r30,r16
 801 0034 4081      		ld r20,Z
 802               	.LVL64:
 803 0036 3181      		ldd r19,Z+1
 804               	.LVL65:
 805 0038 F280      		ldd r15,Z+2
 806               	.LVL66:
  63:../../tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 807               		.loc 1 63 0
 808 003a 2581      		ldd r18,Z+5
 809 003c 2295      		swap r18
 810 003e 2F70      		andi r18,lo8(15)
 811               	.LVL67:
 812               	.LBB36:
 813               	.LBB37:
 814               		.loc 2 49 0
 815 0040 8381      		ldd r24,Z+3
 816 0042 9481      		ldd r25,Z+4
 817 0044 892B      		or r24,r25
 818 0046 01F0      		breq .L142
 819 0048 3F3F      		cpi r19,lo8(-1)
 820 004a 01F4      		brne .L143
 821 004c 81E0      		ldi r24,lo8(1)
 822 004e 4F3F      		cpi r20,lo8(-1)
 823 0050 01F4      		brne .L143
 824 0052 00C0      		rjmp .L71
 825               	.LVL68:
 826               	.L142:
 827 0054 81E0      		ldi r24,lo8(1)
 828               	.LVL69:
 829 0056 00C0      		rjmp .L71
 830               	.L143:
 831 0058 80E0      		ldi r24,0
 832               	.L71:
 833               	.LBE37:
 834               	.LBE36:
  66:../../tmk_core/common/action.c ****     if (IS_NOEVENT(event)) { return; }
 835               		.loc 1 66 0
 836 005a 80FD      		sbrc r24,0
 837 005c 00C0      		rjmp .L70
  68:../../tmk_core/common/action.c ****     action_t action = layer_switch_get_action(event.key);
 838               		.loc 1 68 0
 839 005e 4983      		std Y+1,r20
 840 0060 3A83      		std Y+2,r19
 841 0062 8981      		ldd r24,Y+1
 842 0064 9A81      		ldd r25,Y+2
 843 0066 2F83      		std Y+7,r18
 844               	.LVL70:
 845 0068 0E94 0000 		call layer_switch_get_action
 846               	.LVL71:
  71:../../tmk_core/common/action.c ****     dprint(" layer_state: "); layer_debug();
 847               		.loc 1 71 0
 848 006c 9E83      		std Y+6,r25
 849 006e 8887      		std Y+8,r24
 850 0070 0E94 0000 		call layer_debug
 851               	.LVL72:
  72:../../tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 852               		.loc 1 72 0
 853 0074 0E94 0000 		call default_layer_debug
 854               	.LVL73:
  76:../../tmk_core/common/action.c ****     switch (action.kind.id) {
 855               		.loc 1 76 0
 856 0078 4E81      		ldd r20,Y+6
 857 007a E42F      		mov r30,r20
 858               	.LVL74:
 859 007c E295      		swap r30
 860 007e EF70      		andi r30,lo8(15)
 861 0080 F0E0      		ldi r31,0
 862 0082 E050      		subi r30,lo8(-(gs(.L76)))
 863 0084 F040      		sbci r31,hi8(-(gs(.L76)))
 864 0086 2F81      		ldd r18,Y+7
 865 0088 6885      		ldd r22,Y+8
 866 008a 0C94 0000 		jmp __tablejump2__
 867               		.section	.progmem.gcc_sw_table.process_action,"a",@progbits
 868               		.p2align	1
 869               	.L76:
 870 0000 0000      		.word gs(.L75)
 871 0002 0000      		.word gs(.L75)
 872 0004 0000      		.word gs(.L77)
 873 0006 0000      		.word gs(.L77)
 874 0008 0000      		.word gs(.L78)
 875 000a 0000      		.word gs(.L79)
 876 000c 0000      		.word gs(.L70)
 877 000e 0000      		.word gs(.L70)
 878 0010 0000      		.word gs(.L80)
 879 0012 0000      		.word gs(.L70)
 880 0014 0000      		.word gs(.L81)
 881 0016 0000      		.word gs(.L81)
 882 0018 0000      		.word gs(.L82)
 883 001a 0000      		.word gs(.L70)
 884 001c 0000      		.word gs(.L70)
 885 001e 0000      		.word gs(.L83)
 886               		.section	.text.process_action
 887               	.L75:
 888               	.LBB38:
  81:../../tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
 889               		.loc 1 81 0
 890 008e 842F      		mov r24,r20
 891 0090 807F      		andi r24,lo8(-16)
 892 0092 142F      		mov r17,r20
 893 0094 1F70      		andi r17,lo8(15)
 894 0096 8823      		tst r24
 895 0098 01F0      		breq .L85
  81:../../tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
 896               		.loc 1 81 0 is_stmt 0 discriminator 2
 897 009a 1295      		swap r17
 898 009c 107F      		andi r17,lo8(-16)
 899               	.L85:
 900               	.LVL75:
  83:../../tmk_core/common/action.c ****                 if (event.pressed) {
 901               		.loc 1 83 0 is_stmt 1 discriminator 3
 902 009e FF20      		tst r15
 903 00a0 01F0      		breq .L86
  84:../../tmk_core/common/action.c ****                     if (mods) {
 904               		.loc 1 84 0
 905 00a2 1123      		tst r17
 906 00a4 01F4      		brne .+2
 907 00a6 00C0      		rjmp .L173
  85:../../tmk_core/common/action.c ****                         add_weak_mods(mods);
 908               		.loc 1 85 0
 909 00a8 812F      		mov r24,r17
 910 00aa 6887      		std Y+8,r22
 911 00ac 0E94 0000 		call add_weak_mods
 912               	.LVL76:
  86:../../tmk_core/common/action.c ****                         send_keyboard_report();
 913               		.loc 1 86 0
 914 00b0 0E94 0000 		call send_keyboard_report
 915               	.LVL77:
 916 00b4 6885      		ldd r22,Y+8
 917 00b6 00C0      		rjmp .L173
 918               	.L86:
 919               	.LVL78:
  90:../../tmk_core/common/action.c ****                     unregister_code(action.key.code);
 920               		.loc 1 90 0
 921 00b8 862F      		mov r24,r22
 922 00ba 0E94 0000 		call unregister_code
 923               	.LVL79:
  91:../../tmk_core/common/action.c ****                     if (mods) {
 924               		.loc 1 91 0
 925 00be 1123      		tst r17
 926 00c0 01F4      		brne .+2
 927 00c2 00C0      		rjmp .L70
  92:../../tmk_core/common/action.c ****                         del_weak_mods(mods);
 928               		.loc 1 92 0
 929 00c4 812F      		mov r24,r17
 930 00c6 0E94 0000 		call del_weak_mods
 931               	.LVL80:
 932               	/* epilogue start */
 933               	.LBE38:
 351:../../tmk_core/common/action.c **** }
 934               		.loc 1 351 0
 935 00ca 2896      		adiw r28,8
 936 00cc 0FB6      		in __tmp_reg__,__SREG__
 937 00ce F894      		cli
 938 00d0 DEBF      		out __SP_H__,r29
 939 00d2 0FBE      		out __SREG__,__tmp_reg__
 940 00d4 CDBF      		out __SP_L__,r28
 941 00d6 DF91      		pop r29
 942 00d8 CF91      		pop r28
 943 00da 1F91      		pop r17
 944               	.LVL81:
 945 00dc 0F91      		pop r16
 946               	.LVL82:
 947 00de FF90      		pop r15
 948               	.LVL83:
 949 00e0 EF90      		pop r14
 950 00e2 DF90      		pop r13
 951 00e4 CF90      		pop r12
 952               	.LBB39:
  93:../../tmk_core/common/action.c ****                         send_keyboard_report();
 953               		.loc 1 93 0
 954 00e6 0C94 0000 		jmp send_keyboard_report
 955               	.LVL84:
 956               	.L77:
 957               	.LBE39:
 958               	.LBB40:
 102:../../tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 959               		.loc 1 102 0
 960 00ea 842F      		mov r24,r20
 961 00ec 807F      		andi r24,lo8(-16)
 962 00ee 942F      		mov r25,r20
 963 00f0 9F70      		andi r25,lo8(15)
 964 00f2 E92E      		mov r14,r25
 965 00f4 8032      		cpi r24,lo8(32)
 966 00f6 01F0      		breq .L90
 102:../../tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 967               		.loc 1 102 0 is_stmt 0 discriminator 2
 968 00f8 E294      		swap r14
 969 00fa 80EF      		ldi r24,lo8(-16)
 970 00fc E822      		and r14,r24
 971               	.L90:
 972               	.LVL85:
 104:../../tmk_core/common/action.c ****                 switch (action.key.code) {
 973               		.loc 1 104 0 is_stmt 1 discriminator 3
 974 00fe 6623      		tst r22
 975               	.LVL86:
 976 0100 01F0      		breq .L92
 977 0102 6130      		cpi r22,lo8(1)
 978 0104 01F0      		breq .L93
 979 0106 00C0      		rjmp .L180
 980               	.L92:
 108:../../tmk_core/common/action.c ****                         if (event.pressed) {
 981               		.loc 1 108 0
 982 0108 FF20      		tst r15
 983 010a 01F0      		breq .L94
 110:../../tmk_core/common/action.c ****                                 register_mods(mods);
 984               		.loc 1 110 0
 985 010c 8E2D      		mov r24,r14
 109:../../tmk_core/common/action.c ****                             if (tap_count == 0) {
 986               		.loc 1 109 0
 987 010e 2223      		tst r18
 988 0110 01F0      		breq .L169
 112:../../tmk_core/common/action.c ****                             else if (tap_count == 1) {
 989               		.loc 1 112 0
 990 0112 2130      		cpi r18,lo8(1)
 991 0114 01F4      		brne .L169
 992               	/* epilogue start */
 993               	.LBE40:
 351:../../tmk_core/common/action.c **** }
 994               		.loc 1 351 0
 995 0116 2896      		adiw r28,8
 996 0118 0FB6      		in __tmp_reg__,__SREG__
 997 011a F894      		cli
 998 011c DEBF      		out __SP_H__,r29
 999 011e 0FBE      		out __SREG__,__tmp_reg__
 1000 0120 CDBF      		out __SP_L__,r28
 1001 0122 DF91      		pop r29
 1002 0124 CF91      		pop r28
 1003 0126 1F91      		pop r17
 1004 0128 0F91      		pop r16
 1005               	.LVL87:
 1006 012a FF90      		pop r15
 1007               	.LVL88:
 1008 012c EF90      		pop r14
 1009               	.LVL89:
 1010 012e DF90      		pop r13
 1011 0130 CF90      		pop r12
 1012               	.LBB41:
 114:../../tmk_core/common/action.c ****                                 set_oneshot_mods(mods);
 1013               		.loc 1 114 0
 1014 0132 0C94 0000 		jmp set_oneshot_mods
 1015               	.LVL90:
 1016               	.L94:
 120:../../tmk_core/common/action.c ****                             if (tap_count == 0) {
 1017               		.loc 1 120 0
 1018 0136 2223      		tst r18
 1019 0138 01F0      		breq .L170
 124:../../tmk_core/common/action.c ****                             else if (tap_count == 1) {
 1020               		.loc 1 124 0
 1021 013a 2130      		cpi r18,lo8(1)
 1022 013c 01F4      		brne .+2
 1023 013e 00C0      		rjmp .L70
 1024               	.L170:
 128:../../tmk_core/common/action.c ****                                 clear_oneshot_mods();
 1025               		.loc 1 128 0
 1026 0140 0E94 0000 		call clear_oneshot_mods
 1027               	.LVL91:
 1028 0144 00C0      		rjmp .L104
 1029               	.LVL92:
 1030               	.L93:
 135:../../tmk_core/common/action.c ****                         if (event.pressed) {
 1031               		.loc 1 135 0
 1032 0146 FF20      		tst r15
 1033 0148 01F0      		breq .L99
 136:../../tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1034               		.loc 1 136 0
 1035 014a 2630      		cpi r18,lo8(6)
 1036 014c 00F0      		brlo .+2
 1037 014e 00C0      		rjmp .L70
 137:../../tmk_core/common/action.c ****                                 if (mods & get_mods()) {
 1038               		.loc 1 137 0
 1039 0150 0E94 0000 		call get_mods
 1040               	.LVL93:
 1041 0154 8E21      		and r24,r14
 1042 0156 01F0      		breq .L100
 1043 0158 00C0      		rjmp .L104
 1044               	.LVL94:
 1045               	.L180:
 153:../../tmk_core/common/action.c ****                         if (event.pressed) {
 1046               		.loc 1 153 0
 1047 015a FF20      		tst r15
 1048 015c 01F0      		breq .L101
 154:../../tmk_core/common/action.c ****                             if (tap_count > 0) {
 1049               		.loc 1 154 0
 1050 015e 2111      		cpse r18,__zero_reg__
 1051 0160 00C0      		rjmp .L181
 1052               	.L100:
 142:../../tmk_core/common/action.c ****                                     register_mods(mods);
 1053               		.loc 1 142 0
 1054 0162 8E2D      		mov r24,r14
 1055               	.LVL95:
 1056               	.L169:
 1057               	/* epilogue start */
 1058               	.LBE41:
 351:../../tmk_core/common/action.c **** }
 1059               		.loc 1 351 0
 1060 0164 2896      		adiw r28,8
 1061 0166 0FB6      		in __tmp_reg__,__SREG__
 1062 0168 F894      		cli
 1063 016a DEBF      		out __SP_H__,r29
 1064 016c 0FBE      		out __SREG__,__tmp_reg__
 1065 016e CDBF      		out __SP_L__,r28
 1066 0170 DF91      		pop r29
 1067 0172 CF91      		pop r28
 1068 0174 1F91      		pop r17
 1069 0176 0F91      		pop r16
 1070               	.LVL96:
 1071 0178 FF90      		pop r15
 1072               	.LVL97:
 1073 017a EF90      		pop r14
 1074 017c DF90      		pop r13
 1075 017e CF90      		pop r12
 1076               	.LBB42:
 142:../../tmk_core/common/action.c ****                                     register_mods(mods);
 1077               		.loc 1 142 0
 1078 0180 0C94 0000 		jmp register_mods
 1079               	.LVL98:
 1080               	.L99:
 146:../../tmk_core/common/action.c ****                             if (tap_count < TAPPING_TOGGLE) {
 1081               		.loc 1 146 0
 1082 0184 2530      		cpi r18,lo8(5)
 1083 0186 00F0      		brlo .+2
 1084 0188 00C0      		rjmp .L70
 1085 018a 00C0      		rjmp .L104
 1086               	.L181:
 155:../../tmk_core/common/action.c ****                                 if (record->tap.interrupted) {
 1087               		.loc 1 155 0
 1088 018c F801      		movw r30,r16
 1089 018e 8581      		ldd r24,Z+5
 1090 0190 80FF      		sbrs r24,0
 1091 0192 00C0      		rjmp .L173
 158:../../tmk_core/common/action.c ****                                     record->tap.count = 0;
 1092               		.loc 1 158 0
 1093 0194 8F70      		andi r24,lo8(15)
 1094 0196 8583      		std Z+5,r24
 1095 0198 00C0      		rjmp .L100
 1096               	.L101:
 169:../../tmk_core/common/action.c ****                             if (tap_count > 0) {
 1097               		.loc 1 169 0
 1098 019a 2111      		cpse r18,__zero_reg__
 1099 019c 00C0      		rjmp .L174
 1100               	.L104:
 174:../../tmk_core/common/action.c ****                                 unregister_mods(mods);
 1101               		.loc 1 174 0
 1102 019e 8E2D      		mov r24,r14
 1103 01a0 00C0      		rjmp .L134
 1104               	.LVL99:
 1105               	.L78:
 1106               	.LBE42:
 185:../../tmk_core/common/action.c ****             switch (action.usage.page) {
 1107               		.loc 1 185 0
 1108 01a2 242F      		mov r18,r20
 1109 01a4 2695      		lsr r18
 1110 01a6 2695      		lsr r18
 1111 01a8 2370      		andi r18,lo8(3)
 1112 01aa 30E0      		ldi r19,0
 1113 01ac 2115      		cp r18,__zero_reg__
 1114 01ae 3105      		cpc r19,__zero_reg__
 1115 01b0 01F0      		breq .L105
 1116 01b2 2130      		cpi r18,1
 1117 01b4 3105      		cpc r19,__zero_reg__
 1118 01b6 01F0      		breq .L106
 1119 01b8 00C0      		rjmp .L70
 1120               	.L105:
 187:../../tmk_core/common/action.c ****                     if (event.pressed) {
 1121               		.loc 1 187 0
 1122 01ba FF20      		tst r15
 1123 01bc 01F0      		breq .L107
 1124               	.LVL100:
 188:../../tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1125               		.loc 1 188 0
 1126 01be 862F      		mov r24,r22
 1127 01c0 942F      		mov r25,r20
 1128 01c2 9370      		andi r25,lo8(3)
 1129 01c4 00C0      		rjmp .L175
 1130               	.LVL101:
 1131               	.L107:
 190:../../tmk_core/common/action.c ****                         host_system_send(0);
 1132               		.loc 1 190 0
 1133 01c6 80E0      		ldi r24,0
 1134 01c8 90E0      		ldi r25,0
 1135               	.LVL102:
 1136               	.L175:
 1137               	/* epilogue start */
 351:../../tmk_core/common/action.c **** }
 1138               		.loc 1 351 0
 1139 01ca 2896      		adiw r28,8
 1140 01cc 0FB6      		in __tmp_reg__,__SREG__
 1141 01ce F894      		cli
 1142 01d0 DEBF      		out __SP_H__,r29
 1143 01d2 0FBE      		out __SREG__,__tmp_reg__
 1144 01d4 CDBF      		out __SP_L__,r28
 1145 01d6 DF91      		pop r29
 1146 01d8 CF91      		pop r28
 1147 01da 1F91      		pop r17
 1148 01dc 0F91      		pop r16
 1149               	.LVL103:
 1150 01de FF90      		pop r15
 1151               	.LVL104:
 1152 01e0 EF90      		pop r14
 1153 01e2 DF90      		pop r13
 1154 01e4 CF90      		pop r12
 190:../../tmk_core/common/action.c ****                         host_system_send(0);
 1155               		.loc 1 190 0
 1156 01e6 0C94 0000 		jmp host_system_send
 1157               	.LVL105:
 1158               	.L106:
 194:../../tmk_core/common/action.c ****                     if (event.pressed) {
 1159               		.loc 1 194 0
 1160 01ea FF20      		tst r15
 1161 01ec 01F0      		breq .L108
 1162               	.LVL106:
 195:../../tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1163               		.loc 1 195 0
 1164 01ee 862F      		mov r24,r22
 1165 01f0 942F      		mov r25,r20
 1166 01f2 9370      		andi r25,lo8(3)
 1167 01f4 00C0      		rjmp .L177
 1168               	.LVL107:
 1169               	.L108:
 197:../../tmk_core/common/action.c ****                         host_consumer_send(0);
 1170               		.loc 1 197 0
 1171 01f6 80E0      		ldi r24,0
 1172 01f8 90E0      		ldi r25,0
 1173               	.LVL108:
 1174               	.L177:
 1175               	/* epilogue start */
 351:../../tmk_core/common/action.c **** }
 1176               		.loc 1 351 0
 1177 01fa 2896      		adiw r28,8
 1178 01fc 0FB6      		in __tmp_reg__,__SREG__
 1179 01fe F894      		cli
 1180 0200 DEBF      		out __SP_H__,r29
 1181 0202 0FBE      		out __SREG__,__tmp_reg__
 1182 0204 CDBF      		out __SP_L__,r28
 1183 0206 DF91      		pop r29
 1184 0208 CF91      		pop r28
 1185 020a 1F91      		pop r17
 1186 020c 0F91      		pop r16
 1187               	.LVL109:
 1188 020e FF90      		pop r15
 1189               	.LVL110:
 1190 0210 EF90      		pop r14
 1191 0212 DF90      		pop r13
 1192 0214 CF90      		pop r12
 197:../../tmk_core/common/action.c ****                         host_consumer_send(0);
 1193               		.loc 1 197 0
 1194 0216 0C94 0000 		jmp host_consumer_send
 1195               	.LVL111:
 1196               	.L79:
 207:../../tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1197               		.loc 1 207 0
 1198 021a 862F      		mov r24,r22
 206:../../tmk_core/common/action.c ****             if (event.pressed) {
 1199               		.loc 1 206 0
 1200 021c FF20      		tst r15
 1201 021e 01F0      		breq .L109
 207:../../tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 1202               		.loc 1 207 0
 1203 0220 0E94 0000 		call mousekey_on
 1204               	.LVL112:
 1205 0224 00C0      		rjmp .L178
 1206               	.LVL113:
 1207               	.L109:
 210:../../tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 1208               		.loc 1 210 0
 1209 0226 0E94 0000 		call mousekey_off
 1210               	.LVL114:
 1211               	.L178:
 1212               	/* epilogue start */
 351:../../tmk_core/common/action.c **** }
 1213               		.loc 1 351 0
 1214 022a 2896      		adiw r28,8
 1215 022c 0FB6      		in __tmp_reg__,__SREG__
 1216 022e F894      		cli
 1217 0230 DEBF      		out __SP_H__,r29
 1218 0232 0FBE      		out __SREG__,__tmp_reg__
 1219 0234 CDBF      		out __SP_L__,r28
 1220 0236 DF91      		pop r29
 1221 0238 CF91      		pop r28
 1222 023a 1F91      		pop r17
 1223 023c 0F91      		pop r16
 1224               	.LVL115:
 1225 023e FF90      		pop r15
 1226               	.LVL116:
 1227 0240 EF90      		pop r14
 1228 0242 DF90      		pop r13
 1229 0244 CF90      		pop r12
 211:../../tmk_core/common/action.c ****                 mousekey_send();
 1230               		.loc 1 211 0
 1231 0246 0C94 0000 		jmp mousekey_send
 1232               	.LVL117:
 1233               	.L80:
 217:../../tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 1234               		.loc 1 217 0
 1235 024a 842F      		mov r24,r20
 1236 024c 8370      		andi r24,lo8(3)
 1237 024e 01F0      		breq .+2
 1238 0250 00C0      		rjmp .L110
 219:../../tmk_core/common/action.c ****                 if (!event.pressed) {
 1239               		.loc 1 219 0
 1240 0252 F110      		cpse r15,__zero_reg__
 1241 0254 00C0      		rjmp .L70
 1242               	.LVL118:
 1243               	.LBB43:
 220:../../tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1244               		.loc 1 220 0
 1245 0256 262F      		mov r18,r22
 1246 0258 2295      		swap r18
 1247 025a 2695      		lsr r18
 1248 025c 2770      		andi r18,lo8(7)
 1249 025e 220F      		lsl r18
 1250 0260 220F      		lsl r18
 221:../../tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1251               		.loc 1 221 0
 1252 0262 862F      		mov r24,r22
 1253 0264 8F70      		andi r24,lo8(15)
 1254 0266 C82E      		mov r12,r24
 1255 0268 D12C      		mov r13,__zero_reg__
 1256 026a E12C      		mov r14,__zero_reg__
 1257 026c F12C      		mov r15,__zero_reg__
 1258 026e 022E      		mov r0,r18
 1259 0270 00C0      		rjmp 2f
 1260               		1:
 1261 0272 CC0C      		lsl r12
 1262 0274 DD1C      		rol r13
 1263 0276 EE1C      		rol r14
 1264 0278 FF1C      		rol r15
 1265               		2:
 1266 027a 0A94      		dec r0
 1267 027c 02F4      		brpl 1b
 1268               	.LVL119:
 222:../../tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1269               		.loc 1 222 0
 1270 027e 64FF      		sbrs r22,4
 1271 0280 00C0      		rjmp .L144
 222:../../tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1272               		.loc 1 222 0 is_stmt 0 discriminator 1
 1273 0282 6FE0      		ldi r22,lo8(15)
 1274 0284 70E0      		ldi r23,0
 1275 0286 80E0      		ldi r24,0
 1276 0288 90E0      		ldi r25,0
 1277               	.LVL120:
 1278 028a 00C0      		rjmp 2f
 1279               		1:
 1280 028c 660F      		lsl r22
 1281 028e 771F      		rol r23
 1282 0290 881F      		rol r24
 1283 0292 991F      		rol r25
 1284               		2:
 1285 0294 2A95      		dec r18
 1286 0296 02F4      		brpl 1b
 1287 0298 6095      		com r22
 1288 029a 7095      		com r23
 1289 029c 8095      		com r24
 1290 029e 9095      		com r25
 1291 02a0 00C0      		rjmp .L111
 1292               	.LVL121:
 1293               	.L144:
 222:../../tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1294               		.loc 1 222 0
 1295 02a2 60E0      		ldi r22,0
 1296 02a4 70E0      		ldi r23,0
 1297 02a6 CB01      		movw r24,r22
 1298               	.LVL122:
 1299               	.L111:
 223:../../tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1300               		.loc 1 223 0 is_stmt 1 discriminator 3
 1301 02a8 242F      		mov r18,r20
 1302 02aa 2695      		lsr r18
 1303 02ac 2695      		lsr r18
 1304 02ae 2370      		andi r18,lo8(3)
 1305 02b0 422F      		mov r20,r18
 1306               	.LVL123:
 1307 02b2 50E0      		ldi r21,0
 1308 02b4 4230      		cpi r20,2
 1309 02b6 5105      		cpc r21,__zero_reg__
 1310 02b8 01F0      		breq .L113
 1311 02ba 4330      		cpi r20,3
 1312 02bc 5105      		cpc r21,__zero_reg__
 1313 02be 01F0      		breq .L114
 1314 02c0 6C29      		or r22,r12
 1315 02c2 7D29      		or r23,r13
 1316 02c4 8E29      		or r24,r14
 1317 02c6 9F29      		or r25,r15
 1318               	.LVL124:
 1319 02c8 4130      		cpi r20,1
 1320 02ca 5105      		cpc r21,__zero_reg__
 1321 02cc 01F0      		breq .L179
 1322               	/* epilogue start */
 1323               	.LBE43:
 351:../../tmk_core/common/action.c **** }
 1324               		.loc 1 351 0 discriminator 3
 1325 02ce 2896      		adiw r28,8
 1326               	.LVL125:
 1327 02d0 0FB6      		in __tmp_reg__,__SREG__
 1328 02d2 F894      		cli
 1329 02d4 DEBF      		out __SP_H__,r29
 1330 02d6 0FBE      		out __SREG__,__tmp_reg__
 1331 02d8 CDBF      		out __SP_L__,r28
 1332 02da DF91      		pop r29
 1333 02dc CF91      		pop r28
 1334               	.LVL126:
 1335 02de 1F91      		pop r17
 1336 02e0 0F91      		pop r16
 1337               	.LVL127:
 1338 02e2 FF90      		pop r15
 1339               	.LVL128:
 1340 02e4 EF90      		pop r14
 1341 02e6 DF90      		pop r13
 1342 02e8 CF90      		pop r12
 1343               	.LVL129:
 1344               	.LBB44:
 224:../../tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1345               		.loc 1 224 0 discriminator 3
 1346 02ea 0C94 0000 		jmp default_layer_and
 1347               	.LVL130:
 1348               	.L113:
 226:../../tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 1349               		.loc 1 226 0
 1350 02ee 6C29      		or r22,r12
 1351 02f0 7D29      		or r23,r13
 1352 02f2 8E29      		or r24,r14
 1353 02f4 9F29      		or r25,r15
 1354               	.LVL131:
 1355               	/* epilogue start */
 1356               	.LBE44:
 351:../../tmk_core/common/action.c **** }
 1357               		.loc 1 351 0
 1358 02f6 2896      		adiw r28,8
 1359               	.LVL132:
 1360 02f8 0FB6      		in __tmp_reg__,__SREG__
 1361 02fa F894      		cli
 1362 02fc DEBF      		out __SP_H__,r29
 1363 02fe 0FBE      		out __SREG__,__tmp_reg__
 1364 0300 CDBF      		out __SP_L__,r28
 1365 0302 DF91      		pop r29
 1366 0304 CF91      		pop r28
 1367               	.LVL133:
 1368 0306 1F91      		pop r17
 1369 0308 0F91      		pop r16
 1370               	.LVL134:
 1371 030a FF90      		pop r15
 1372               	.LVL135:
 1373 030c EF90      		pop r14
 1374 030e DF90      		pop r13
 1375 0310 CF90      		pop r12
 1376               	.LVL136:
 1377               	.LBB45:
 226:../../tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 1378               		.loc 1 226 0
 1379 0312 0C94 0000 		jmp default_layer_xor
 1380               	.LVL137:
 1381               	.L114:
 227:../../tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1382               		.loc 1 227 0
 1383 0316 0E94 0000 		call default_layer_and
 1384               	.LVL138:
 1385 031a C701      		movw r24,r14
 1386 031c B601      		movw r22,r12
 1387               	.L179:
 1388               	/* epilogue start */
 1389               	.LBE45:
 351:../../tmk_core/common/action.c **** }
 1390               		.loc 1 351 0
 1391 031e 2896      		adiw r28,8
 1392 0320 0FB6      		in __tmp_reg__,__SREG__
 1393 0322 F894      		cli
 1394 0324 DEBF      		out __SP_H__,r29
 1395 0326 0FBE      		out __SREG__,__tmp_reg__
 1396 0328 CDBF      		out __SP_L__,r28
 1397 032a DF91      		pop r29
 1398 032c CF91      		pop r28
 1399 032e 1F91      		pop r17
 1400 0330 0F91      		pop r16
 1401               	.LVL139:
 1402 0332 FF90      		pop r15
 1403               	.LVL140:
 1404 0334 EF90      		pop r14
 1405 0336 DF90      		pop r13
 1406 0338 CF90      		pop r12
 1407               	.LVL141:
 1408               	.LBB46:
 227:../../tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1409               		.loc 1 227 0
 1410 033a 0C94 0000 		jmp default_layer_or
 1411               	.LVL142:
 1412               	.L110:
 1413               	.LBE46:
 232:../../tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 1414               		.loc 1 232 0
 1415 033e FF20      		tst r15
 1416 0340 01F0      		breq .L116
 232:../../tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 1417               		.loc 1 232 0 is_stmt 0 discriminator 1
 1418 0342 842F      		mov r24,r20
 1419 0344 8170      		andi r24,lo8(1)
 1420 0346 00C0      		rjmp .L117
 1421               	.L116:
 232:../../tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 1422               		.loc 1 232 0 discriminator 2
 1423 0348 8695      		lsr r24
 1424               	.L117:
 232:../../tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 1425               		.loc 1 232 0 discriminator 3
 1426 034a 8823      		tst r24
 1427 034c 01F4      		brne .+2
 1428 034e 00C0      		rjmp .L70
 1429               	.LVL143:
 1430               	.LBB47:
 234:../../tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1431               		.loc 1 234 0 is_stmt 1
 1432 0350 262F      		mov r18,r22
 1433 0352 2295      		swap r18
 1434 0354 2695      		lsr r18
 1435 0356 2770      		andi r18,lo8(7)
 1436 0358 220F      		lsl r18
 1437 035a 220F      		lsl r18
 235:../../tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1438               		.loc 1 235 0
 1439 035c 862F      		mov r24,r22
 1440 035e 8F70      		andi r24,lo8(15)
 1441 0360 C82E      		mov r12,r24
 1442 0362 D12C      		mov r13,__zero_reg__
 1443 0364 E12C      		mov r14,__zero_reg__
 1444 0366 F12C      		mov r15,__zero_reg__
 1445 0368 022E      		mov r0,r18
 1446 036a 00C0      		rjmp 2f
 1447               		1:
 1448 036c CC0C      		lsl r12
 1449 036e DD1C      		rol r13
 1450 0370 EE1C      		rol r14
 1451 0372 FF1C      		rol r15
 1452               		2:
 1453 0374 0A94      		dec r0
 1454 0376 02F4      		brpl 1b
 1455               	.LVL144:
 236:../../tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1456               		.loc 1 236 0
 1457 0378 64FF      		sbrs r22,4
 1458 037a 00C0      		rjmp .L145
 236:../../tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1459               		.loc 1 236 0 is_stmt 0 discriminator 1
 1460 037c 6FE0      		ldi r22,lo8(15)
 1461 037e 70E0      		ldi r23,0
 1462 0380 80E0      		ldi r24,0
 1463 0382 90E0      		ldi r25,0
 1464               	.LVL145:
 1465 0384 00C0      		rjmp 2f
 1466               		1:
 1467 0386 660F      		lsl r22
 1468 0388 771F      		rol r23
 1469 038a 881F      		rol r24
 1470 038c 991F      		rol r25
 1471               		2:
 1472 038e 2A95      		dec r18
 1473 0390 02F4      		brpl 1b
 1474 0392 6095      		com r22
 1475 0394 7095      		com r23
 1476 0396 8095      		com r24
 1477 0398 9095      		com r25
 1478 039a 00C0      		rjmp .L118
 1479               	.LVL146:
 1480               	.L145:
 236:../../tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1481               		.loc 1 236 0
 1482 039c 60E0      		ldi r22,0
 1483 039e 70E0      		ldi r23,0
 1484 03a0 CB01      		movw r24,r22
 1485               	.LVL147:
 1486               	.L118:
 237:../../tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1487               		.loc 1 237 0 is_stmt 1 discriminator 3
 1488 03a2 242F      		mov r18,r20
 1489 03a4 2695      		lsr r18
 1490 03a6 2695      		lsr r18
 1491 03a8 2370      		andi r18,lo8(3)
 1492 03aa 422F      		mov r20,r18
 1493               	.LVL148:
 1494 03ac 50E0      		ldi r21,0
 1495 03ae 4230      		cpi r20,2
 1496 03b0 5105      		cpc r21,__zero_reg__
 1497 03b2 01F0      		breq .L120
 1498 03b4 4330      		cpi r20,3
 1499 03b6 5105      		cpc r21,__zero_reg__
 1500 03b8 01F0      		breq .L121
 1501 03ba 6C29      		or r22,r12
 1502 03bc 7D29      		or r23,r13
 1503 03be 8E29      		or r24,r14
 1504 03c0 9F29      		or r25,r15
 1505               	.LVL149:
 1506 03c2 4130      		cpi r20,1
 1507 03c4 5105      		cpc r21,__zero_reg__
 1508 03c6 01F0      		breq .L176
 1509               	/* epilogue start */
 1510               	.LBE47:
 351:../../tmk_core/common/action.c **** }
 1511               		.loc 1 351 0 discriminator 3
 1512 03c8 2896      		adiw r28,8
 1513               	.LVL150:
 1514 03ca 0FB6      		in __tmp_reg__,__SREG__
 1515 03cc F894      		cli
 1516 03ce DEBF      		out __SP_H__,r29
 1517 03d0 0FBE      		out __SREG__,__tmp_reg__
 1518 03d2 CDBF      		out __SP_L__,r28
 1519 03d4 DF91      		pop r29
 1520 03d6 CF91      		pop r28
 1521               	.LVL151:
 1522 03d8 1F91      		pop r17
 1523 03da 0F91      		pop r16
 1524               	.LVL152:
 1525 03dc FF90      		pop r15
 1526               	.LVL153:
 1527 03de EF90      		pop r14
 1528 03e0 DF90      		pop r13
 1529 03e2 CF90      		pop r12
 1530               	.LVL154:
 1531               	.LBB48:
 238:../../tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1532               		.loc 1 238 0 discriminator 3
 1533 03e4 0C94 0000 		jmp layer_and
 1534               	.LVL155:
 1535               	.L120:
 240:../../tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 1536               		.loc 1 240 0
 1537 03e8 6C29      		or r22,r12
 1538 03ea 7D29      		or r23,r13
 1539 03ec 8E29      		or r24,r14
 1540 03ee 9F29      		or r25,r15
 1541               	.LVL156:
 1542               	/* epilogue start */
 1543               	.LBE48:
 351:../../tmk_core/common/action.c **** }
 1544               		.loc 1 351 0
 1545 03f0 2896      		adiw r28,8
 1546               	.LVL157:
 1547 03f2 0FB6      		in __tmp_reg__,__SREG__
 1548 03f4 F894      		cli
 1549 03f6 DEBF      		out __SP_H__,r29
 1550 03f8 0FBE      		out __SREG__,__tmp_reg__
 1551 03fa CDBF      		out __SP_L__,r28
 1552 03fc DF91      		pop r29
 1553 03fe CF91      		pop r28
 1554               	.LVL158:
 1555 0400 1F91      		pop r17
 1556 0402 0F91      		pop r16
 1557               	.LVL159:
 1558 0404 FF90      		pop r15
 1559               	.LVL160:
 1560 0406 EF90      		pop r14
 1561 0408 DF90      		pop r13
 1562 040a CF90      		pop r12
 1563               	.LVL161:
 1564               	.LBB49:
 240:../../tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 1565               		.loc 1 240 0
 1566 040c 0C94 0000 		jmp layer_xor
 1567               	.LVL162:
 1568               	.L121:
 241:../../tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1569               		.loc 1 241 0
 1570 0410 0E94 0000 		call layer_and
 1571               	.LVL163:
 1572 0414 C701      		movw r24,r14
 1573 0416 B601      		movw r22,r12
 1574               	.L176:
 1575               	/* epilogue start */
 1576               	.LBE49:
 351:../../tmk_core/common/action.c **** }
 1577               		.loc 1 351 0
 1578 0418 2896      		adiw r28,8
 1579 041a 0FB6      		in __tmp_reg__,__SREG__
 1580 041c F894      		cli
 1581 041e DEBF      		out __SP_H__,r29
 1582 0420 0FBE      		out __SREG__,__tmp_reg__
 1583 0422 CDBF      		out __SP_L__,r28
 1584 0424 DF91      		pop r29
 1585 0426 CF91      		pop r28
 1586 0428 1F91      		pop r17
 1587 042a 0F91      		pop r16
 1588               	.LVL164:
 1589 042c FF90      		pop r15
 1590               	.LVL165:
 1591 042e EF90      		pop r14
 1592 0430 DF90      		pop r13
 1593 0432 CF90      		pop r12
 1594               	.LVL166:
 1595               	.LBB50:
 241:../../tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1596               		.loc 1 241 0
 1597 0434 0C94 0000 		jmp layer_or
 1598               	.LVL167:
 1599               	.L81:
 1600               	.LBE50:
 249:../../tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 1601               		.loc 1 249 0
 1602 0438 603F      		cpi r22,lo8(-16)
 1603 043a 01F0      		breq .L124
 1604               	.LVL168:
 1605 043c 00F4      		brsh .L125
 1606 043e 80E4      		ldi r24,lo8(64)
 1607 0440 860F      		add r24,r22
 1608 0442 8032      		cpi r24,lo8(32)
 1609 0444 00F0      		brlo .L168
 1610 0446 00C0      		rjmp .L123
 1611               	.L125:
 1612 0448 623F      		cpi r22,lo8(-14)
 1613 044a 01F4      		brne .+2
 1614 044c 00C0      		rjmp .L127
 1615 044e 00F4      		brsh .+2
 1616 0450 00C0      		rjmp .L128
 1617 0452 633F      		cpi r22,lo8(-13)
 1618 0454 01F4      		brne .+2
 1619 0456 00C0      		rjmp .L129
 1620 0458 00C0      		rjmp .L123
 1621               	.L168:
 1622 045a 162F      		mov r17,r22
 1623 045c 1071      		andi r17,lo8(16)
 1624 045e 842F      		mov r24,r20
 1625 0460 8F71      		andi r24,lo8(31)
 253:../../tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1626               		.loc 1 253 0
 1627 0462 6887      		std Y+8,r22
 1628               	.LVL169:
 252:../../tmk_core/common/action.c ****                     if (event.pressed) {
 1629               		.loc 1 252 0
 1630 0464 FF20      		tst r15
 1631 0466 01F0      		breq .L130
 253:../../tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1632               		.loc 1 253 0
 1633 0468 0E94 0000 		call layer_on
 1634               	.LVL170:
 254:../../tmk_core/common/action.c ****                         register_mods((action.layer_tap.code & 0x10) ?
 1635               		.loc 1 254 0
 1636 046c 6885      		ldd r22,Y+8
 1637 046e 862F      		mov r24,r22
 1638 0470 1123      		tst r17
 1639 0472 01F0      		breq .L131
 1640 0474 8295      		swap r24
 1641 0476 807F      		andi r24,lo8(-16)
 1642 0478 00C0      		rjmp .L169
 1643               	.L131:
 254:../../tmk_core/common/action.c ****                         register_mods((action.layer_tap.code & 0x10) ?
 1644               		.loc 1 254 0 is_stmt 0 discriminator 1
 1645 047a 8F70      		andi r24,lo8(15)
 1646 047c 00C0      		rjmp .L169
 1647               	.L130:
 258:../../tmk_core/common/action.c ****                         layer_off(action.layer_tap.val);
 1648               		.loc 1 258 0 is_stmt 1
 1649 047e 0E94 0000 		call layer_off
 1650               	.LVL171:
 259:../../tmk_core/common/action.c ****                         unregister_mods((action.layer_tap.code & 0x10) ?
 1651               		.loc 1 259 0
 1652 0482 6885      		ldd r22,Y+8
 1653 0484 862F      		mov r24,r22
 1654 0486 1123      		tst r17
 1655 0488 01F0      		breq .L133
 1656 048a 8295      		swap r24
 1657 048c 807F      		andi r24,lo8(-16)
 1658 048e 00C0      		rjmp .L134
 1659               	.L133:
 259:../../tmk_core/common/action.c ****                         unregister_mods((action.layer_tap.code & 0x10) ?
 1660               		.loc 1 259 0 is_stmt 0 discriminator 1
 1661 0490 8F70      		andi r24,lo8(15)
 1662               	.LVL172:
 1663               	.L134:
 1664               	/* epilogue start */
 351:../../tmk_core/common/action.c **** }
 1665               		.loc 1 351 0 is_stmt 1 discriminator 2
 1666 0492 2896      		adiw r28,8
 1667 0494 0FB6      		in __tmp_reg__,__SREG__
 1668 0496 F894      		cli
 1669 0498 DEBF      		out __SP_H__,r29
 1670 049a 0FBE      		out __SREG__,__tmp_reg__
 1671 049c CDBF      		out __SP_L__,r28
 1672 049e DF91      		pop r29
 1673 04a0 CF91      		pop r28
 1674 04a2 1F91      		pop r17
 1675 04a4 0F91      		pop r16
 1676               	.LVL173:
 1677 04a6 FF90      		pop r15
 1678               	.LVL174:
 1679 04a8 EF90      		pop r14
 1680 04aa DF90      		pop r13
 1681 04ac CF90      		pop r12
 259:../../tmk_core/common/action.c ****                         unregister_mods((action.layer_tap.code & 0x10) ?
 1682               		.loc 1 259 0 discriminator 2
 1683 04ae 0C94 0000 		jmp unregister_mods
 1684               	.LVL175:
 1685               	.L124:
 266:../../tmk_core/common/action.c ****                     if (event.pressed) {
 1686               		.loc 1 266 0
 1687 04b2 FF20      		tst r15
 1688 04b4 01F0      		breq .L135
 267:../../tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1689               		.loc 1 267 0
 1690 04b6 2530      		cpi r18,lo8(5)
 1691 04b8 00F0      		brlo .+2
 1692 04ba 00C0      		rjmp .L70
 1693               	.L136:
 268:../../tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1694               		.loc 1 268 0
 1695 04bc 842F      		mov r24,r20
 1696 04be 8F71      		andi r24,lo8(31)
 1697               	/* epilogue start */
 351:../../tmk_core/common/action.c **** }
 1698               		.loc 1 351 0
 1699 04c0 2896      		adiw r28,8
 1700 04c2 0FB6      		in __tmp_reg__,__SREG__
 1701 04c4 F894      		cli
 1702 04c6 DEBF      		out __SP_H__,r29
 1703 04c8 0FBE      		out __SREG__,__tmp_reg__
 1704 04ca CDBF      		out __SP_L__,r28
 1705 04cc DF91      		pop r29
 1706 04ce CF91      		pop r28
 1707 04d0 1F91      		pop r17
 1708 04d2 0F91      		pop r16
 1709               	.LVL176:
 1710 04d4 FF90      		pop r15
 1711               	.LVL177:
 1712 04d6 EF90      		pop r14
 1713 04d8 DF90      		pop r13
 1714 04da CF90      		pop r12
 268:../../tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1715               		.loc 1 268 0
 1716 04dc 0C94 0000 		jmp layer_invert
 1717               	.LVL178:
 1718               	.L135:
 271:../../tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1719               		.loc 1 271 0
 1720 04e0 2630      		cpi r18,lo8(6)
 1721 04e2 00F0      		brlo .+2
 1722 04e4 00C0      		rjmp .L70
 1723 04e6 00C0      		rjmp .L136
 1724               	.L128:
 277:../../tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 1725               		.loc 1 277 0
 1726 04e8 FF20      		tst r15
 1727 04ea 01F0      		breq .L137
 1728               	.L138:
 277:../../tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 1729               		.loc 1 277 0 is_stmt 0 discriminator 1
 1730 04ec 842F      		mov r24,r20
 1731 04ee 8F71      		andi r24,lo8(31)
 1732               	/* epilogue start */
 351:../../tmk_core/common/action.c **** }
 1733               		.loc 1 351 0 is_stmt 1 discriminator 1
 1734 04f0 2896      		adiw r28,8
 1735 04f2 0FB6      		in __tmp_reg__,__SREG__
 1736 04f4 F894      		cli
 1737 04f6 DEBF      		out __SP_H__,r29
 1738 04f8 0FBE      		out __SREG__,__tmp_reg__
 1739 04fa CDBF      		out __SP_L__,r28
 1740 04fc DF91      		pop r29
 1741 04fe CF91      		pop r28
 1742 0500 1F91      		pop r17
 1743 0502 0F91      		pop r16
 1744               	.LVL179:
 1745 0504 FF90      		pop r15
 1746               	.LVL180:
 1747 0506 EF90      		pop r14
 1748 0508 DF90      		pop r13
 1749 050a CF90      		pop r12
 277:../../tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 1750               		.loc 1 277 0 discriminator 1
 1751 050c 0C94 0000 		jmp layer_on
 1752               	.LVL181:
 1753               	.L127:
 281:../../tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) :
 1754               		.loc 1 281 0
 1755 0510 FF20      		tst r15
 1756 0512 01F0      		breq .L138
 1757               	.L137:
 278:../../tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1758               		.loc 1 278 0
 1759 0514 842F      		mov r24,r20
 1760 0516 8F71      		andi r24,lo8(31)
 1761               	/* epilogue start */
 351:../../tmk_core/common/action.c **** }
 1762               		.loc 1 351 0
 1763 0518 2896      		adiw r28,8
 1764 051a 0FB6      		in __tmp_reg__,__SREG__
 1765 051c F894      		cli
 1766 051e DEBF      		out __SP_H__,r29
 1767 0520 0FBE      		out __SREG__,__tmp_reg__
 1768 0522 CDBF      		out __SP_L__,r28
 1769 0524 DF91      		pop r29
 1770 0526 CF91      		pop r28
 1771 0528 1F91      		pop r17
 1772 052a 0F91      		pop r16
 1773               	.LVL182:
 1774 052c FF90      		pop r15
 1775               	.LVL183:
 1776 052e EF90      		pop r14
 1777 0530 DF90      		pop r13
 1778 0532 CF90      		pop r12
 278:../../tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1779               		.loc 1 278 0
 1780 0534 0C94 0000 		jmp layer_off
 1781               	.LVL184:
 1782               	.L129:
 285:../../tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 1783               		.loc 1 285 0
 1784 0538 FF20      		tst r15
 1785 053a 01F0      		breq .L139
 285:../../tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 1786               		.loc 1 285 0 is_stmt 0 discriminator 1
 1787 053c 842F      		mov r24,r20
 1788 053e 8F71      		andi r24,lo8(31)
 1789               	/* epilogue start */
 351:../../tmk_core/common/action.c **** }
 1790               		.loc 1 351 0 is_stmt 1 discriminator 1
 1791 0540 2896      		adiw r28,8
 1792 0542 0FB6      		in __tmp_reg__,__SREG__
 1793 0544 F894      		cli
 1794 0546 DEBF      		out __SP_H__,r29
 1795 0548 0FBE      		out __SREG__,__tmp_reg__
 1796 054a CDBF      		out __SP_L__,r28
 1797 054c DF91      		pop r29
 1798 054e CF91      		pop r28
 1799 0550 1F91      		pop r17
 1800 0552 0F91      		pop r16
 1801               	.LVL185:
 1802 0554 FF90      		pop r15
 1803               	.LVL186:
 1804 0556 EF90      		pop r14
 1805 0558 DF90      		pop r13
 1806 055a CF90      		pop r12
 285:../../tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 1807               		.loc 1 285 0 discriminator 1
 1808 055c 0C94 0000 		jmp layer_move
 1809               	.LVL187:
 1810               	.L139:
 1811               	/* epilogue start */
 351:../../tmk_core/common/action.c **** }
 1812               		.loc 1 351 0
 1813 0560 2896      		adiw r28,8
 1814 0562 0FB6      		in __tmp_reg__,__SREG__
 1815 0564 F894      		cli
 1816 0566 DEBF      		out __SP_H__,r29
 1817 0568 0FBE      		out __SREG__,__tmp_reg__
 1818 056a CDBF      		out __SP_L__,r28
 1819 056c DF91      		pop r29
 1820 056e CF91      		pop r28
 1821 0570 1F91      		pop r17
 1822 0572 0F91      		pop r16
 1823               	.LVL188:
 1824 0574 FF90      		pop r15
 1825               	.LVL189:
 1826 0576 EF90      		pop r14
 1827 0578 DF90      		pop r13
 1828 057a CF90      		pop r12
 286:../../tmk_core/common/action.c ****                                     layer_clear();
 1829               		.loc 1 286 0
 1830 057c 0C94 0000 		jmp layer_clear
 1831               	.LVL190:
 1832               	.L123:
 290:../../tmk_core/common/action.c ****                     if (event.pressed) {
 1833               		.loc 1 290 0
 1834 0580 FF20      		tst r15
 1835 0582 01F0      		breq .L140
 291:../../tmk_core/common/action.c ****                         if (tap_count > 0) {
 1836               		.loc 1 291 0
 1837 0584 2223      		tst r18
 1838 0586 01F4      		brne .+2
 1839 0588 00C0      		rjmp .L138
 1840               	.L173:
 293:../../tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 1841               		.loc 1 293 0
 1842 058a 862F      		mov r24,r22
 1843               	/* epilogue start */
 351:../../tmk_core/common/action.c **** }
 1844               		.loc 1 351 0
 1845 058c 2896      		adiw r28,8
 1846 058e 0FB6      		in __tmp_reg__,__SREG__
 1847 0590 F894      		cli
 1848 0592 DEBF      		out __SP_H__,r29
 1849 0594 0FBE      		out __SREG__,__tmp_reg__
 1850 0596 CDBF      		out __SP_L__,r28
 1851 0598 DF91      		pop r29
 1852 059a CF91      		pop r28
 1853 059c 1F91      		pop r17
 1854 059e 0F91      		pop r16
 1855               	.LVL191:
 1856 05a0 FF90      		pop r15
 1857               	.LVL192:
 1858 05a2 EF90      		pop r14
 1859 05a4 DF90      		pop r13
 1860 05a6 CF90      		pop r12
 293:../../tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 1861               		.loc 1 293 0
 1862 05a8 0C94 0000 		jmp register_code
 1863               	.LVL193:
 1864               	.L140:
 299:../../tmk_core/common/action.c ****                         if (tap_count > 0) {
 1865               		.loc 1 299 0
 1866 05ac 2223      		tst r18
 1867 05ae 01F4      		brne .+2
 1868 05b0 00C0      		rjmp .L137
 1869               	.L174:
 301:../../tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 1870               		.loc 1 301 0
 1871 05b2 862F      		mov r24,r22
 1872               	/* epilogue start */
 351:../../tmk_core/common/action.c **** }
 1873               		.loc 1 351 0
 1874 05b4 2896      		adiw r28,8
 1875 05b6 0FB6      		in __tmp_reg__,__SREG__
 1876 05b8 F894      		cli
 1877 05ba DEBF      		out __SP_H__,r29
 1878 05bc 0FBE      		out __SREG__,__tmp_reg__
 1879 05be CDBF      		out __SP_L__,r28
 1880 05c0 DF91      		pop r29
 1881 05c2 CF91      		pop r28
 1882 05c4 1F91      		pop r17
 1883 05c6 0F91      		pop r16
 1884               	.LVL194:
 1885 05c8 FF90      		pop r15
 1886               	.LVL195:
 1887 05ca EF90      		pop r14
 1888 05cc DF90      		pop r13
 1889 05ce CF90      		pop r12
 301:../../tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 1890               		.loc 1 301 0
 1891 05d0 0C94 0000 		jmp unregister_code
 1892               	.LVL196:
 1893               	.L82:
 315:../../tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 1894               		.loc 1 315 0
 1895 05d4 4F70      		andi r20,lo8(15)
 1896 05d6 C801      		movw r24,r16
 1897 05d8 0E94 0000 		call action_get_macro
 1898               	.LVL197:
 1899               	/* epilogue start */
 351:../../tmk_core/common/action.c **** }
 1900               		.loc 1 351 0
 1901 05dc 2896      		adiw r28,8
 1902 05de 0FB6      		in __tmp_reg__,__SREG__
 1903 05e0 F894      		cli
 1904 05e2 DEBF      		out __SP_H__,r29
 1905 05e4 0FBE      		out __SREG__,__tmp_reg__
 1906 05e6 CDBF      		out __SP_L__,r28
 1907 05e8 DF91      		pop r29
 1908 05ea CF91      		pop r28
 1909 05ec 1F91      		pop r17
 1910 05ee 0F91      		pop r16
 1911               	.LVL198:
 1912 05f0 FF90      		pop r15
 1913               	.LVL199:
 1914 05f2 EF90      		pop r14
 1915 05f4 DF90      		pop r13
 1916 05f6 CF90      		pop r12
 315:../../tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 1917               		.loc 1 315 0
 1918 05f8 0C94 0000 		jmp action_macro_play
 1919               	.LVL200:
 1920               	.L83:
 345:../../tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 1921               		.loc 1 345 0
 1922 05fc 4F70      		andi r20,lo8(15)
 1923 05fe C801      		movw r24,r16
 1924               	/* epilogue start */
 351:../../tmk_core/common/action.c **** }
 1925               		.loc 1 351 0
 1926 0600 2896      		adiw r28,8
 1927 0602 0FB6      		in __tmp_reg__,__SREG__
 1928 0604 F894      		cli
 1929 0606 DEBF      		out __SP_H__,r29
 1930 0608 0FBE      		out __SREG__,__tmp_reg__
 1931 060a CDBF      		out __SP_L__,r28
 1932 060c DF91      		pop r29
 1933 060e CF91      		pop r28
 1934 0610 1F91      		pop r17
 1935 0612 0F91      		pop r16
 1936               	.LVL201:
 1937 0614 FF90      		pop r15
 1938               	.LVL202:
 1939 0616 EF90      		pop r14
 1940 0618 DF90      		pop r13
 1941 061a CF90      		pop r12
 345:../../tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 1942               		.loc 1 345 0
 1943 061c 0C94 0000 		jmp action_function
 1944               	.LVL203:
 1945               	.L70:
 1946               	/* epilogue start */
 351:../../tmk_core/common/action.c **** }
 1947               		.loc 1 351 0
 1948 0620 2896      		adiw r28,8
 1949 0622 0FB6      		in __tmp_reg__,__SREG__
 1950 0624 F894      		cli
 1951 0626 DEBF      		out __SP_H__,r29
 1952 0628 0FBE      		out __SREG__,__tmp_reg__
 1953 062a CDBF      		out __SP_L__,r28
 1954 062c DF91      		pop r29
 1955 062e CF91      		pop r28
 1956 0630 1F91      		pop r17
 1957 0632 0F91      		pop r16
 1958               	.LVL204:
 1959 0634 FF90      		pop r15
 1960               	.LVL205:
 1961 0636 EF90      		pop r14
 1962 0638 DF90      		pop r13
 1963 063a CF90      		pop r12
 1964 063c 0895      		ret
 1965               		.cfi_endproc
 1966               	.LFE11:
 1968               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 1969               	.global	clear_keyboard_but_mods
 1971               	clear_keyboard_but_mods:
 1972               	.LFB17:
 508:../../tmk_core/common/action.c ****     }
 509:../../tmk_core/common/action.c **** }
 510:../../tmk_core/common/action.c **** 
 511:../../tmk_core/common/action.c **** void clear_keyboard(void)
 512:../../tmk_core/common/action.c **** {
 513:../../tmk_core/common/action.c ****     clear_mods();
 514:../../tmk_core/common/action.c ****     clear_keyboard_but_mods();
 515:../../tmk_core/common/action.c **** }
 516:../../tmk_core/common/action.c **** 
 517:../../tmk_core/common/action.c **** void clear_keyboard_but_mods(void)
 518:../../tmk_core/common/action.c **** {
 1973               		.loc 1 518 0
 1974               		.cfi_startproc
 1975               	/* prologue: function */
 1976               	/* frame size = 0 */
 1977               	/* stack size = 0 */
 1978               	.L__stack_usage = 0
 519:../../tmk_core/common/action.c ****     clear_weak_mods();
 1979               		.loc 1 519 0
 1980 0000 0E94 0000 		call clear_weak_mods
 1981               	.LVL206:
 520:../../tmk_core/common/action.c ****     clear_keys();
 1982               		.loc 1 520 0
 1983 0004 0E94 0000 		call clear_keys
 1984               	.LVL207:
 521:../../tmk_core/common/action.c ****     send_keyboard_report();
 1985               		.loc 1 521 0
 1986 0008 0E94 0000 		call send_keyboard_report
 1987               	.LVL208:
 522:../../tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 523:../../tmk_core/common/action.c ****     mousekey_clear();
 1988               		.loc 1 523 0
 1989 000c 0E94 0000 		call mousekey_clear
 1990               	.LVL209:
 524:../../tmk_core/common/action.c ****     mousekey_send();
 1991               		.loc 1 524 0
 1992 0010 0E94 0000 		call mousekey_send
 1993               	.LVL210:
 525:../../tmk_core/common/action.c **** #endif
 526:../../tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 527:../../tmk_core/common/action.c ****     host_system_send(0);
 1994               		.loc 1 527 0
 1995 0014 80E0      		ldi r24,0
 1996 0016 90E0      		ldi r25,0
 1997 0018 0E94 0000 		call host_system_send
 1998               	.LVL211:
 528:../../tmk_core/common/action.c ****     host_consumer_send(0);
 1999               		.loc 1 528 0
 2000 001c 80E0      		ldi r24,0
 2001 001e 90E0      		ldi r25,0
 2002 0020 0C94 0000 		jmp host_consumer_send
 2003               	.LVL212:
 2004               		.cfi_endproc
 2005               	.LFE17:
 2007               		.section	.text.clear_keyboard,"ax",@progbits
 2008               	.global	clear_keyboard
 2010               	clear_keyboard:
 2011               	.LFB16:
 512:../../tmk_core/common/action.c **** {
 2012               		.loc 1 512 0
 2013               		.cfi_startproc
 2014               	/* prologue: function */
 2015               	/* frame size = 0 */
 2016               	/* stack size = 0 */
 2017               	.L__stack_usage = 0
 513:../../tmk_core/common/action.c ****     clear_mods();
 2018               		.loc 1 513 0
 2019 0000 0E94 0000 		call clear_mods
 2020               	.LVL213:
 514:../../tmk_core/common/action.c ****     clear_keyboard_but_mods();
 2021               		.loc 1 514 0
 2022 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2023               	.LVL214:
 2024               		.cfi_endproc
 2025               	.LFE16:
 2027               		.section	.text.is_tap_key,"ax",@progbits
 2028               	.global	is_tap_key
 2030               	is_tap_key:
 2031               	.LFB18:
 529:../../tmk_core/common/action.c **** #endif
 530:../../tmk_core/common/action.c **** }
 531:../../tmk_core/common/action.c **** 
 532:../../tmk_core/common/action.c **** bool is_tap_key(keypos_t key)
 533:../../tmk_core/common/action.c **** {
 2032               		.loc 1 533 0
 2033               		.cfi_startproc
 2034               	.LVL215:
 2035               	/* prologue: function */
 2036               	/* frame size = 0 */
 2037               	/* stack size = 0 */
 2038               	.L__stack_usage = 0
 534:../../tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2039               		.loc 1 534 0
 2040 0000 0E94 0000 		call layer_switch_get_action
 2041               	.LVL216:
 535:../../tmk_core/common/action.c **** 
 536:../../tmk_core/common/action.c ****     switch (action.kind.id) {
 2042               		.loc 1 536 0
 2043 0004 292F      		mov r18,r25
 2044 0006 2295      		swap r18
 2045 0008 2F70      		andi r18,lo8(15)
 2046 000a 30E0      		ldi r19,0
 2047 000c 2C30      		cpi r18,12
 2048 000e 3105      		cpc r19,__zero_reg__
 2049 0010 04F4      		brge .L186
 2050 0012 2A30      		cpi r18,10
 2051 0014 3105      		cpc r19,__zero_reg__
 2052 0016 04F4      		brge .L187
 2053 0018 2250      		subi r18,2
 2054 001a 3109      		sbc r19,__zero_reg__
 2055 001c 2230      		cpi r18,2
 2056 001e 3105      		cpc r19,__zero_reg__
 2057 0020 00F0      		brlo .L205
 2058 0022 00C0      		rjmp .L193
 2059               	.L186:
 2060 0024 2C30      		cpi r18,12
 2061 0026 3105      		cpc r19,__zero_reg__
 2062 0028 01F0      		breq .L189
 2063 002a 2F30      		cpi r18,15
 2064 002c 3105      		cpc r19,__zero_reg__
 2065 002e 01F0      		breq .L189
 2066 0030 00C0      		rjmp .L193
 2067               	.L205:
 537:../../tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 538:../../tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 539:../../tmk_core/common/action.c ****             switch (action.key.code) {
 2068               		.loc 1 539 0
 2069 0032 853A      		cpi r24,lo8(-91)
 2070 0034 00F4      		brsh .L190
 2071 0036 8430      		cpi r24,lo8(4)
 2072 0038 00F4      		brsh .L195
 2073 003a 8230      		cpi r24,lo8(2)
 2074 003c 00F4      		brsh .L187
 2075 003e 00C0      		rjmp .L195
 2076               	.L190:
 2077 0040 90E2      		ldi r25,lo8(32)
 2078               	.LVL217:
 2079 0042 980F      		add r25,r24
 2080 0044 9830      		cpi r25,lo8(8)
 2081 0046 00F0      		brlo .L195
 2082               	.LVL218:
 2083               	.L187:
 540:../../tmk_core/common/action.c ****                 case MODS_ONESHOT:
 541:../../tmk_core/common/action.c ****                 case MODS_TAP_TOGGLE:
 542:../../tmk_core/common/action.c ****                 case KC_A ... KC_EXSEL:                 // tap key
 543:../../tmk_core/common/action.c ****                 case KC_LCTRL ... KC_RGUI:              // tap key
 544:../../tmk_core/common/action.c ****                     return true;
 545:../../tmk_core/common/action.c ****             }
 546:../../tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 547:../../tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 548:../../tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 2084               		.loc 1 548 0
 2085 0048 883E      		cpi r24,lo8(-24)
 2086 004a 00F4      		brsh .L192
 2087 004c 803E      		cpi r24,lo8(-32)
 2088 004e 00F4      		brsh .L195
 2089 0050 8450      		subi r24,lo8(-(-4))
 2090               	.LVL219:
 2091 0052 813A      		cpi r24,lo8(-95)
 2092 0054 00F4      		brsh .L193
 2093 0056 00C0      		rjmp .L195
 2094               	.LVL220:
 2095               	.L192:
 2096 0058 803F      		cpi r24,lo8(-16)
 2097 005a 01F4      		brne .L193
 2098 005c 00C0      		rjmp .L195
 2099               	.L189:
 549:../../tmk_core/common/action.c ****                 case 0xc0 ... 0xdf:         // with modifiers
 550:../../tmk_core/common/action.c ****                     return false;
 551:../../tmk_core/common/action.c ****                 case KC_A ... KC_EXSEL:     // tap key
 552:../../tmk_core/common/action.c ****                 case KC_LCTRL ... KC_RGUI:  // tap key
 553:../../tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 554:../../tmk_core/common/action.c ****                     return true;
 555:../../tmk_core/common/action.c ****             }
 556:../../tmk_core/common/action.c ****             return false;
 557:../../tmk_core/common/action.c ****         case ACT_MACRO:
 558:../../tmk_core/common/action.c ****         case ACT_FUNCTION:
 559:../../tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) { return true; }
 2100               		.loc 1 559 0
 2101 005e 93FB      		bst r25,3
 2102 0060 8827      		clr r24
 2103 0062 80F9      		bld r24,0
 2104               	.LVL221:
 2105 0064 0895      		ret
 2106               	.LVL222:
 2107               	.L193:
 560:../../tmk_core/common/action.c ****             return false;
 561:../../tmk_core/common/action.c ****     }
 562:../../tmk_core/common/action.c ****     return false;
 2108               		.loc 1 562 0
 2109 0066 80E0      		ldi r24,0
 2110               	.LVL223:
 2111 0068 0895      		ret
 2112               	.LVL224:
 2113               	.L195:
 554:../../tmk_core/common/action.c ****                     return true;
 2114               		.loc 1 554 0
 2115 006a 81E0      		ldi r24,lo8(1)
 2116               	.LVL225:
 563:../../tmk_core/common/action.c **** }
 2117               		.loc 1 563 0
 2118 006c 0895      		ret
 2119               		.cfi_endproc
 2120               	.LFE18:
 2122               		.section	.text.debug_event,"ax",@progbits
 2123               	.global	debug_event
 2125               	debug_event:
 2126               	.LFB19:
 564:../../tmk_core/common/action.c **** 
 565:../../tmk_core/common/action.c **** 
 566:../../tmk_core/common/action.c **** /*
 567:../../tmk_core/common/action.c ****  * debug print
 568:../../tmk_core/common/action.c ****  */
 569:../../tmk_core/common/action.c **** void debug_event(keyevent_t event)
 570:../../tmk_core/common/action.c **** {
 2127               		.loc 1 570 0
 2128               		.cfi_startproc
 2129 0000 CF93      		push r28
 2130               	.LCFI15:
 2131               		.cfi_def_cfa_offset 3
 2132               		.cfi_offset 28, -2
 2133 0002 DF93      		push r29
 2134               	.LCFI16:
 2135               		.cfi_def_cfa_offset 4
 2136               		.cfi_offset 29, -3
 2137 0004 00D0      		rcall .
 2138 0006 00D0      		rcall .
 2139 0008 1F92      		push __zero_reg__
 2140               	.LCFI17:
 2141               		.cfi_def_cfa_offset 9
 2142 000a CDB7      		in r28,__SP_L__
 2143 000c DEB7      		in r29,__SP_H__
 2144               	.LCFI18:
 2145               		.cfi_def_cfa_register 28
 2146               	/* prologue: function */
 2147               	/* frame size = 5 */
 2148               	/* stack size = 7 */
 2149               	.L__stack_usage = 7
 2150               	/* epilogue start */
 571:../../tmk_core/common/action.c ****     dprintf("%04X%c(%u)", (event.key.row<<8 | event.key.col), (event.pressed ? 'd' : 'u'), event.ti
 572:../../tmk_core/common/action.c **** }
 2151               		.loc 1 572 0
 2152 000e 0F90      		pop __tmp_reg__
 2153 0010 0F90      		pop __tmp_reg__
 2154 0012 0F90      		pop __tmp_reg__
 2155 0014 0F90      		pop __tmp_reg__
 2156 0016 0F90      		pop __tmp_reg__
 2157 0018 DF91      		pop r29
 2158 001a CF91      		pop r28
 2159 001c 0895      		ret
 2160               		.cfi_endproc
 2161               	.LFE19:
 2163               		.section	.text.debug_record,"ax",@progbits
 2164               	.global	debug_record
 2166               	debug_record:
 2167               	.LFB20:
 573:../../tmk_core/common/action.c **** 
 574:../../tmk_core/common/action.c **** void debug_record(keyrecord_t record)
 575:../../tmk_core/common/action.c **** {
 2168               		.loc 1 575 0
 2169               		.cfi_startproc
 2170 0000 CF93      		push r28
 2171               	.LCFI19:
 2172               		.cfi_def_cfa_offset 3
 2173               		.cfi_offset 28, -2
 2174 0002 DF93      		push r29
 2175               	.LCFI20:
 2176               		.cfi_def_cfa_offset 4
 2177               		.cfi_offset 29, -3
 2178 0004 00D0      		rcall .
 2179 0006 00D0      		rcall .
 2180 0008 00D0      		rcall .
 2181               	.LCFI21:
 2182               		.cfi_def_cfa_offset 10
 2183 000a CDB7      		in r28,__SP_L__
 2184 000c DEB7      		in r29,__SP_H__
 2185               	.LCFI22:
 2186               		.cfi_def_cfa_register 28
 2187               	/* prologue: function */
 2188               	/* frame size = 6 */
 2189               	/* stack size = 8 */
 2190               	.L__stack_usage = 8
 2191               	/* epilogue start */
 576:../../tmk_core/common/action.c ****     debug_event(record.event);
 577:../../tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 578:../../tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 579:../../tmk_core/common/action.c **** #endif
 580:../../tmk_core/common/action.c **** }
 2192               		.loc 1 580 0
 2193 000e 2696      		adiw r28,6
 2194 0010 0FB6      		in __tmp_reg__,__SREG__
 2195 0012 F894      		cli
 2196 0014 DEBF      		out __SP_H__,r29
 2197 0016 0FBE      		out __SREG__,__tmp_reg__
 2198 0018 CDBF      		out __SP_L__,r28
 2199 001a DF91      		pop r29
 2200 001c CF91      		pop r28
 2201 001e 0895      		ret
 2202               		.cfi_endproc
 2203               	.LFE20:
 2205               		.section	.text.debug_action,"ax",@progbits
 2206               	.global	debug_action
 2208               	debug_action:
 2209               	.LFB21:
 581:../../tmk_core/common/action.c **** 
 582:../../tmk_core/common/action.c **** void debug_action(action_t action)
 583:../../tmk_core/common/action.c **** {
 2210               		.loc 1 583 0
 2211               		.cfi_startproc
 2212               	.LVL226:
 2213               	/* prologue: function */
 2214               	/* frame size = 0 */
 2215               	/* stack size = 0 */
 2216               	.L__stack_usage = 0
 2217 0000 0895      		ret
 2218               		.cfi_endproc
 2219               	.LFE21:
 2221               		.text
 2222               	.Letext0:
 2223               		.file 4 "/usr/lib/avr/include/stdint.h"
 2224               		.file 5 "../../tmk_core/common/keycode.h"
 2225               		.file 6 "../../tmk_core/common/action_code.h"
 2226               		.file 7 "../../tmk_core/common/action_macro.h"
 2227               		.file 8 "../../tmk_core/common/action.h"
 2228               		.file 9 "../../tmk_core/common/hook.h"
 2229               		.file 10 "../../tmk_core/common/action_tapping.h"
 2230               		.file 11 "../../tmk_core/common/action_util.h"
 2231               		.file 12 "../../tmk_core/common/host.h"
 2232               		.file 13 "../../tmk_core/common/action_layer.h"
 2233               		.file 14 "../../tmk_core/common/command.h"
 2234               		.file 15 "../../tmk_core/common/mousekey.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
     /tmp/ccziZTWd.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccziZTWd.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccziZTWd.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccziZTWd.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccziZTWd.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccziZTWd.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccziZTWd.s:14     .text.action_exec:0000000000000000 action_exec
     /tmp/ccziZTWd.s:129    .text.register_code:0000000000000000 register_code
     /tmp/ccziZTWd.s:505    .text.unregister_code:0000000000000000 unregister_code
     /tmp/ccziZTWd.s:683    .text.register_mods:0000000000000000 register_mods
     /tmp/ccziZTWd.s:709    .text.unregister_mods:0000000000000000 unregister_mods
     /tmp/ccziZTWd.s:735    .text.process_action:0000000000000000 process_action
     /tmp/ccziZTWd.s:1971   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
     /tmp/ccziZTWd.s:2010   .text.clear_keyboard:0000000000000000 clear_keyboard
     /tmp/ccziZTWd.s:2030   .text.is_tap_key:0000000000000000 is_tap_key
     /tmp/ccziZTWd.s:2125   .text.debug_event:0000000000000000 debug_event
     /tmp/ccziZTWd.s:2166   .text.debug_record:0000000000000000 debug_record
     /tmp/ccziZTWd.s:2208   .text.debug_action:0000000000000000 debug_action

UNDEFINED SYMBOLS
hook_matrix_change
action_tapping_process
host_keyboard_leds
add_key
send_keyboard_report
del_key
command_proc
add_mods
host_system_send
host_consumer_send
del_mods
layer_switch_get_action
layer_debug
default_layer_debug
__tablejump2__
add_weak_mods
del_weak_mods
set_oneshot_mods
clear_oneshot_mods
get_mods
mousekey_on
mousekey_off
mousekey_send
default_layer_and
default_layer_xor
default_layer_or
layer_and
layer_xor
layer_or
layer_on
layer_off
layer_invert
layer_move
layer_clear
action_get_macro
action_macro_play
action_function
clear_weak_mods
clear_keys
mousekey_clear
clear_mods

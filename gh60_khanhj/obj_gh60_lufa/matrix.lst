   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  11               		.section	.text.unselect_rows,"ax",@progbits
  13               	unselect_rows:
  14               	.LFB12:
  15               		.file 1 "matrix.c"
   1:matrix.c      **** /*
   2:matrix.c      **** Copyright 2012 Jun Wako <wakojun@gmail.com>
   3:matrix.c      **** 
   4:matrix.c      **** This program is free software: you can redistribute it and/or modify
   5:matrix.c      **** it under the terms of the GNU General Public License as published by
   6:matrix.c      **** the Free Software Foundation, either version 2 of the License, or
   7:matrix.c      **** (at your option) any later version.
   8:matrix.c      **** 
   9:matrix.c      **** This program is distributed in the hope that it will be useful,
  10:matrix.c      **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:matrix.c      **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:matrix.c      **** GNU General Public License for more details.
  13:matrix.c      **** 
  14:matrix.c      **** You should have received a copy of the GNU General Public License
  15:matrix.c      **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:matrix.c      **** */
  17:matrix.c      **** 
  18:matrix.c      **** /*
  19:matrix.c      ****  * scan matrix
  20:matrix.c      ****  */
  21:matrix.c      **** #include <stdint.h>
  22:matrix.c      **** #include <stdbool.h>
  23:matrix.c      **** #include <avr/io.h>
  24:matrix.c      **** #include <util/delay.h>
  25:matrix.c      **** #include "print.h"
  26:matrix.c      **** #include "debug.h"
  27:matrix.c      **** #include "util.h"
  28:matrix.c      **** #include "matrix.h"
  29:matrix.c      **** 
  30:matrix.c      **** 
  31:matrix.c      **** #ifndef DEBOUNCE
  32:matrix.c      **** #   define DEBOUNCE	5
  33:matrix.c      **** #endif
  34:matrix.c      **** static uint8_t debouncing = DEBOUNCE;
  35:matrix.c      **** 
  36:matrix.c      **** /* matrix state(1:on, 0:off) */
  37:matrix.c      **** static matrix_row_t matrix[MATRIX_ROWS];
  38:matrix.c      **** static matrix_row_t matrix_debouncing[MATRIX_ROWS];
  39:matrix.c      **** 
  40:matrix.c      **** static matrix_row_t read_cols(void);
  41:matrix.c      **** static void init_cols(void);
  42:matrix.c      **** static void unselect_rows(void);
  43:matrix.c      **** static void select_row(uint8_t row);
  44:matrix.c      **** 
  45:matrix.c      **** 
  46:matrix.c      **** void matrix_init(void)
  47:matrix.c      **** {
  48:matrix.c      ****     // initialize row and col
  49:matrix.c      ****     unselect_rows();
  50:matrix.c      ****     init_cols();
  51:matrix.c      **** 
  52:matrix.c      ****     // initialize matrix state: all keys off
  53:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  54:matrix.c      ****         matrix[i] = 0;
  55:matrix.c      ****         matrix_debouncing[i] = 0;
  56:matrix.c      ****     }
  57:matrix.c      **** }
  58:matrix.c      **** 
  59:matrix.c      **** uint8_t matrix_scan(void)
  60:matrix.c      **** {
  61:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  62:matrix.c      ****         select_row(i);
  63:matrix.c      ****         _delay_us(30);  // without this wait read unstable value.
  64:matrix.c      ****         matrix_row_t cols = read_cols();
  65:matrix.c      ****         if (matrix_debouncing[i] != cols) {
  66:matrix.c      ****             matrix_debouncing[i] = cols;
  67:matrix.c      ****             if (debouncing) {
  68:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
  69:matrix.c      ****             }
  70:matrix.c      ****             debouncing = DEBOUNCE;
  71:matrix.c      ****         }
  72:matrix.c      ****         unselect_rows();
  73:matrix.c      ****     }
  74:matrix.c      **** 
  75:matrix.c      ****     if (debouncing) {
  76:matrix.c      ****         if (--debouncing) {
  77:matrix.c      ****             _delay_ms(1);
  78:matrix.c      ****         } else {
  79:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
  80:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
  81:matrix.c      ****             }
  82:matrix.c      ****         }
  83:matrix.c      ****     }
  84:matrix.c      **** 
  85:matrix.c      ****     return 1;
  86:matrix.c      **** }
  87:matrix.c      **** 
  88:matrix.c      **** inline
  89:matrix.c      **** matrix_row_t matrix_get_row(uint8_t row)
  90:matrix.c      **** {
  91:matrix.c      ****     return matrix[row];
  92:matrix.c      **** }
  93:matrix.c      **** 
  94:matrix.c      **** /* Column pin configuration
  95:matrix.c      ****  * col: 0   1   2   3   4   5   6   7   8   9   10  11  12  13
  96:matrix.c      ****  * pin: C0  C1  C2  C3  C4  C5  C6  C7  F0  F1  F2  F3  F4  F5  (Rev.A)
  97:matrix.c      ****  * pin:                                 B7                      (Rev.B)
  98:matrix.c      ****  */
  99:matrix.c      **** static void  init_cols(void)
 100:matrix.c      **** {
 101:matrix.c      ****     // Input with pull-up(DDR:0, PORT:1)
 102:matrix.c      ****     DDRF  &= ~(1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 103:matrix.c      ****     PORTF |=  (1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 104:matrix.c      **** 
 105:matrix.c      ****     DDRC  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 106:matrix.c      ****     PORTC |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
 107:matrix.c      **** 
 108:matrix.c      **** }
 109:matrix.c      **** 
 110:matrix.c      **** static matrix_row_t read_cols(void)
 111:matrix.c      **** {
 112:matrix.c      ****     return (PINC&(1<<0) ? 0 : (1<<0)) |
 113:matrix.c      ****            (PINC&(1<<1) ? 0 : (1<<1)) |
 114:matrix.c      ****            (PINC&(1<<2) ? 0 : (1<<2)) |
 115:matrix.c      ****            (PINC&(1<<3) ? 0 : (1<<3)) |
 116:matrix.c      ****            (PINC&(1<<4) ? 0 : (1<<4)) |
 117:matrix.c      ****            (PINC&(1<<5) ? 0 : (1<<5)) |
 118:matrix.c      ****            (PINC&(1<<6) ? 0 : (1<<6)) |
 119:matrix.c      ****            (PINC&(1<<7) ? 0 : (1<<7)) |
 120:matrix.c      ****            (PINF&(1<<0) ? 0 : (1<<8)) |     
 121:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<<9)) |
 122:matrix.c      ****            (PINF&(1<<2) ? 0 : (1<<10)) |
 123:matrix.c      ****            (PINF&(1<<3) ? 0 : (1<<11)) |
 124:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<12)) |
 125:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<13));
 126:matrix.c      **** }
 127:matrix.c      **** 
 128:matrix.c      **** /* Row pin configuration
 129:matrix.c      ****  * row: 0   1   2   3   4   5
 130:matrix.c      ****  * pin: D2  D3  D4  D5  D6  D7
 131:matrix.c      ****  */
 132:matrix.c      **** static void unselect_rows(void)
 133:matrix.c      **** {
  16               		.loc 1 133 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 134:matrix.c      ****     // Hi-Z(DDR:0, PORT:0) to unselect
 135:matrix.c      ****     DDRD  &= ~0b11111100;
  22               		.loc 1 135 0
  23 0000 8AB1      		in r24,0xa
  24 0002 8370      		andi r24,lo8(3)
  25 0004 8AB9      		out 0xa,r24
 136:matrix.c      ****     PORTD &= ~0b11111100;
  26               		.loc 1 136 0
  27 0006 8BB1      		in r24,0xb
  28 0008 8370      		andi r24,lo8(3)
  29 000a 8BB9      		out 0xb,r24
  30 000c 0895      		ret
  31               		.cfi_endproc
  32               	.LFE12:
  34               		.section	.text.matrix_init,"ax",@progbits
  35               	.global	matrix_init
  37               	matrix_init:
  38               	.LFB7:
  47:matrix.c      **** {
  39               		.loc 1 47 0
  40               		.cfi_startproc
  41               	/* prologue: function */
  42               	/* frame size = 0 */
  43               	/* stack size = 0 */
  44               	.L__stack_usage = 0
  49:matrix.c      ****     unselect_rows();
  45               		.loc 1 49 0
  46 0000 0E94 0000 		call unselect_rows
  47               	.LVL0:
  48               	.LBB15:
  49               	.LBB16:
 102:matrix.c      ****     DDRF  &= ~(1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
  50               		.loc 1 102 0
  51 0004 80B3      		in r24,0x10
  52 0006 807C      		andi r24,lo8(-64)
  53 0008 80BB      		out 0x10,r24
 103:matrix.c      ****     PORTF |=  (1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
  54               		.loc 1 103 0
  55 000a 81B3      		in r24,0x11
  56 000c 8F63      		ori r24,lo8(63)
  57 000e 81BB      		out 0x11,r24
 105:matrix.c      ****     DDRC  &= ~(1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
  58               		.loc 1 105 0
  59 0010 87B1      		in r24,0x7
  60 0012 17B8      		out 0x7,__zero_reg__
 106:matrix.c      ****     PORTC |=  (1<<7 | 1<<6 | 1<<5 | 1<<4 | 1<<3 | 1<<2 | 1<<1 | 1<<0);
  61               		.loc 1 106 0
  62 0014 88B1      		in r24,0x8
  63 0016 8FEF      		ldi r24,lo8(-1)
  64 0018 88B9      		out 0x8,r24
  65               	.LVL1:
  66 001a E0E0      		ldi r30,lo8(matrix)
  67 001c F0E0      		ldi r31,hi8(matrix)
  68 001e A0E0      		ldi r26,lo8(matrix_debouncing)
  69 0020 B0E0      		ldi r27,hi8(matrix_debouncing)
  70               	.LVL2:
  71               	.L4:
  72               	.LBE16:
  73               	.LBE15:
  74               	.LBB17:
  54:matrix.c      ****         matrix[i] = 0;
  75               		.loc 1 54 0 discriminator 2
  76 0022 1192      		st Z+,__zero_reg__
  77 0024 1192      		st Z+,__zero_reg__
  55:matrix.c      ****         matrix_debouncing[i] = 0;
  78               		.loc 1 55 0 discriminator 2
  79 0026 1D92      		st X+,__zero_reg__
  80 0028 1D92      		st X+,__zero_reg__
  53:matrix.c      ****     for (uint8_t i=0; i < MATRIX_ROWS; i++) {
  81               		.loc 1 53 0 discriminator 2
  82 002a 80E0      		ldi r24,hi8(matrix+12)
  83 002c E030      		cpi r30,lo8(matrix+12)
  84 002e F807      		cpc r31,r24
  85 0030 01F4      		brne .L4
  86               	/* epilogue start */
  87               	.LBE17:
  57:matrix.c      **** }
  88               		.loc 1 57 0
  89 0032 0895      		ret
  90               		.cfi_endproc
  91               	.LFE7:
  93               		.section	.text.matrix_scan,"ax",@progbits
  94               	.global	matrix_scan
  96               	matrix_scan:
  97               	.LFB8:
  60:matrix.c      **** {
  98               		.loc 1 60 0
  99               		.cfi_startproc
 100 0000 EF92      		push r14
 101               	.LCFI0:
 102               		.cfi_def_cfa_offset 3
 103               		.cfi_offset 14, -2
 104 0002 FF92      		push r15
 105               	.LCFI1:
 106               		.cfi_def_cfa_offset 4
 107               		.cfi_offset 15, -3
 108 0004 0F93      		push r16
 109               	.LCFI2:
 110               		.cfi_def_cfa_offset 5
 111               		.cfi_offset 16, -4
 112 0006 1F93      		push r17
 113               	.LCFI3:
 114               		.cfi_def_cfa_offset 6
 115               		.cfi_offset 17, -5
 116 0008 CF93      		push r28
 117               	.LCFI4:
 118               		.cfi_def_cfa_offset 7
 119               		.cfi_offset 28, -6
 120 000a DF93      		push r29
 121               	.LCFI5:
 122               		.cfi_def_cfa_offset 8
 123               		.cfi_offset 29, -7
 124               	/* prologue: function */
 125               	/* frame size = 0 */
 126               	/* stack size = 6 */
 127               	.L__stack_usage = 6
 128               	.LVL3:
  60:matrix.c      **** {
 129               		.loc 1 60 0
 130 000c C0E0      		ldi r28,lo8(matrix_debouncing)
 131 000e D0E0      		ldi r29,hi8(matrix_debouncing)
 132               	.LBB32:
  61:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 133               		.loc 1 61 0
 134 0010 10E0      		ldi r17,0
 135 0012 01E0      		ldi r16,lo8(1)
 136               	.LBB33:
  68:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 137               		.loc 1 68 0
 138 0014 60E0      		ldi r22,lo8(__c.1887)
 139 0016 E62E      		mov r14,r22
 140 0018 60E0      		ldi r22,hi8(__c.1887)
 141 001a F62E      		mov r15,r22
 142               	.LVL4:
 143               	.L35:
 144               	.LBB34:
 145               	.LBB35:
 137:matrix.c      **** }
 138:matrix.c      **** 
 139:matrix.c      **** static void select_row(uint8_t row)
 140:matrix.c      **** {
 141:matrix.c      ****     // Output low(DDR:1, PORT:0) to select
 142:matrix.c      ****     switch (row) {
 146               		.loc 1 142 0
 147 001c 1330      		cpi r17,lo8(3)
 148 001e 01F0      		breq .L8
 149 0020 00F4      		brsh .L9
 150 0022 1130      		cpi r17,lo8(1)
 151 0024 01F0      		breq .L10
 152 0026 1230      		cpi r17,lo8(2)
 153 0028 01F0      		breq .L11
 154 002a 00C0      		rjmp .L7
 155               	.L9:
 156 002c 1430      		cpi r17,lo8(4)
 157 002e 01F0      		breq .L12
 158 0030 1530      		cpi r17,lo8(5)
 159 0032 01F0      		breq .L13
 160               	.L7:
 143:matrix.c      ****         case 0:
 144:matrix.c      ****             DDRD  |= (1<<2);
 161               		.loc 1 144 0
 162 0034 529A      		sbi 0xa,2
 145:matrix.c      ****             PORTD &= ~(1<<2);
 163               		.loc 1 145 0
 164 0036 5A98      		cbi 0xb,2
 165 0038 00C0      		rjmp .L14
 166               	.L10:
 146:matrix.c      ****             break;
 147:matrix.c      ****         case 1:
 148:matrix.c      ****             DDRD  |= (1<<3);
 167               		.loc 1 148 0
 168 003a 539A      		sbi 0xa,3
 149:matrix.c      ****             PORTD &= ~(1<<3);
 169               		.loc 1 149 0
 170 003c 5B98      		cbi 0xb,3
 171 003e 00C0      		rjmp .L14
 172               	.L11:
 150:matrix.c      ****             break;
 151:matrix.c      ****         case 2:
 152:matrix.c      ****             DDRD  |= (1<<4);
 173               		.loc 1 152 0
 174 0040 549A      		sbi 0xa,4
 153:matrix.c      ****             PORTD &= ~(1<<4);
 175               		.loc 1 153 0
 176 0042 5C98      		cbi 0xb,4
 177 0044 00C0      		rjmp .L14
 178               	.L8:
 154:matrix.c      ****             break;
 155:matrix.c      ****         case 3:
 156:matrix.c      ****             DDRD  |= (1<<5);
 179               		.loc 1 156 0
 180 0046 559A      		sbi 0xa,5
 157:matrix.c      ****             PORTD &= ~(1<<5);
 181               		.loc 1 157 0
 182 0048 5D98      		cbi 0xb,5
 183 004a 00C0      		rjmp .L14
 184               	.L12:
 158:matrix.c      ****             break;
 159:matrix.c      ****         case 4:
 160:matrix.c      ****             DDRD  |= (1<<6);
 185               		.loc 1 160 0
 186 004c 569A      		sbi 0xa,6
 161:matrix.c      ****             PORTD &= ~(1<<6);
 187               		.loc 1 161 0
 188 004e 5E98      		cbi 0xb,6
 189 0050 00C0      		rjmp .L14
 190               	.L13:
 162:matrix.c      ****             break;
 163:matrix.c      ****         case 5:
 164:matrix.c      ****             DDRD  |= (1<<7);
 191               		.loc 1 164 0
 192 0052 579A      		sbi 0xa,7
 165:matrix.c      ****             PORTD &= ~(1<<7);
 193               		.loc 1 165 0
 194 0054 5F98      		cbi 0xb,7
 195               	.L14:
 196               	.LVL5:
 197               	.LBE35:
 198               	.LBE34:
 199               	.LBB36:
 200               	.LBB37:
 201               		.file 2 "/usr/lib/avr/include/util/delay.h"
   1:/usr/lib/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/avr/include/util/delay.h **** 
   6:/usr/lib/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/avr/include/util/delay.h **** 
   9:/usr/lib/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/avr/include/util/delay.h **** 
  12:/usr/lib/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/avr/include/util/delay.h ****      distribution.
  16:/usr/lib/avr/include/util/delay.h **** 
  17:/usr/lib/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/avr/include/util/delay.h **** 
  21:/usr/lib/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/avr/include/util/delay.h **** 
  33:/usr/lib/avr/include/util/delay.h **** /* $Id: delay.h.in 2251 2011-09-14 08:20:33Z joerg_wunsch $ */
  34:/usr/lib/avr/include/util/delay.h **** 
  35:/usr/lib/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/avr/include/util/delay.h **** 
  38:/usr/lib/avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/avr/include/util/delay.h **** #endif
  41:/usr/lib/avr/include/util/delay.h **** 
  42:/usr/lib/avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/avr/include/util/delay.h **** 
  46:/usr/lib/avr/include/util/delay.h **** /** \file */
  47:/usr/lib/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/avr/include/util/delay.h ****     \code
  49:/usr/lib/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/avr/include/util/delay.h ****     \endcode
  53:/usr/lib/avr/include/util/delay.h **** 
  54:/usr/lib/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/avr/include/util/delay.h ****     used.
  58:/usr/lib/avr/include/util/delay.h **** 
  59:/usr/lib/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/avr/include/util/delay.h **** 
  68:/usr/lib/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/avr/include/util/delay.h **** 
  77:/usr/lib/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/avr/include/util/delay.h **** 
  81:/usr/lib/avr/include/util/delay.h **** */
  82:/usr/lib/avr/include/util/delay.h **** 
  83:/usr/lib/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/avr/include/util/delay.h **** #endif
  87:/usr/lib/avr/include/util/delay.h **** 
  88:/usr/lib/avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/avr/include/util/delay.h **** #endif
  93:/usr/lib/avr/include/util/delay.h **** 
  94:/usr/lib/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/avr/include/util/delay.h **** #endif
  97:/usr/lib/avr/include/util/delay.h **** 
  98:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
  99:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 100:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 101:/usr/lib/avr/include/util/delay.h **** #  include <math.h>
 102:/usr/lib/avr/include/util/delay.h **** #endif
 103:/usr/lib/avr/include/util/delay.h **** 
 104:/usr/lib/avr/include/util/delay.h **** /**
 105:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 106:/usr/lib/avr/include/util/delay.h **** 
 107:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 108:/usr/lib/avr/include/util/delay.h **** 
 109:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 110:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 111:/usr/lib/avr/include/util/delay.h **** 
 112:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 113:/usr/lib/avr/include/util/delay.h **** 
 114:/usr/lib/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 115:/usr/lib/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 116:/usr/lib/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 117:/usr/lib/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 118:/usr/lib/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 119:/usr/lib/avr/include/util/delay.h **** 
 120:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 121:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 122:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 123:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0ms.
 124:/usr/lib/avr/include/util/delay.h **** 
 125:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 126:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 127:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 128:/usr/lib/avr/include/util/delay.h **** 
 129:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 130:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 131:/usr/lib/avr/include/util/delay.h **** 
 132:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 133:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 134:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 135:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 136:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 137:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 138:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 139:/usr/lib/avr/include/util/delay.h **** 
 140:/usr/lib/avr/include/util/delay.h ****  */
 141:/usr/lib/avr/include/util/delay.h **** void
 142:/usr/lib/avr/include/util/delay.h **** _delay_ms(double __ms)
 143:/usr/lib/avr/include/util/delay.h **** {
 144:/usr/lib/avr/include/util/delay.h **** 	uint16_t __ticks;
 145:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 146:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 147:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 148:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 149:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 150:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 151:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 152:/usr/lib/avr/include/util/delay.h **** 
 153:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 154:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 155:/usr/lib/avr/include/util/delay.h **** 
 156:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 157:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 158:/usr/lib/avr/include/util/delay.h **** 
 159:/usr/lib/avr/include/util/delay.h **** 	#else
 160:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 161:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 162:/usr/lib/avr/include/util/delay.h **** 	#endif
 163:/usr/lib/avr/include/util/delay.h **** 
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 165:/usr/lib/avr/include/util/delay.h **** 
 166:/usr/lib/avr/include/util/delay.h **** #else
 167:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 168:/usr/lib/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 169:/usr/lib/avr/include/util/delay.h **** 		__ticks = 1;
 170:/usr/lib/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 171:/usr/lib/avr/include/util/delay.h **** 	{
 172:/usr/lib/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 173:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 174:/usr/lib/avr/include/util/delay.h **** 		while(__ticks)
 175:/usr/lib/avr/include/util/delay.h **** 		{
 176:/usr/lib/avr/include/util/delay.h **** 			// wait 1/10 ms
 177:/usr/lib/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 178:/usr/lib/avr/include/util/delay.h **** 			__ticks --;
 179:/usr/lib/avr/include/util/delay.h **** 		}
 180:/usr/lib/avr/include/util/delay.h **** 		return;
 181:/usr/lib/avr/include/util/delay.h **** 	}
 182:/usr/lib/avr/include/util/delay.h **** 	else
 183:/usr/lib/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 184:/usr/lib/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 185:/usr/lib/avr/include/util/delay.h **** #endif
 186:/usr/lib/avr/include/util/delay.h **** }
 187:/usr/lib/avr/include/util/delay.h **** 
 188:/usr/lib/avr/include/util/delay.h **** /**
 189:/usr/lib/avr/include/util/delay.h ****    \ingroup util_delay
 190:/usr/lib/avr/include/util/delay.h **** 
 191:/usr/lib/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 192:/usr/lib/avr/include/util/delay.h **** 
 193:/usr/lib/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 194:/usr/lib/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 195:/usr/lib/avr/include/util/delay.h **** 
 196:/usr/lib/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 197:/usr/lib/avr/include/util/delay.h **** 
 198:/usr/lib/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 199:/usr/lib/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 200:/usr/lib/avr/include/util/delay.h ****    will not be informed about this case.
 201:/usr/lib/avr/include/util/delay.h **** 
 202:/usr/lib/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 203:/usr/lib/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 204:/usr/lib/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 205:/usr/lib/avr/include/util/delay.h ****    no delay i.e., 0us.
 206:/usr/lib/avr/include/util/delay.h ****   
 207:/usr/lib/avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 208:/usr/lib/avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 209:/usr/lib/avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 210:/usr/lib/avr/include/util/delay.h **** 
 211:/usr/lib/avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 212:/usr/lib/avr/include/util/delay.h ****    to round down and round to closest integer.
 213:/usr/lib/avr/include/util/delay.h ****  
 214:/usr/lib/avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 215:/usr/lib/avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 216:/usr/lib/avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay.
 217:/usr/lib/avr/include/util/delay.h ****    Also, the backward compatible
 218:/usr/lib/avr/include/util/delay.h ****    algorithm will be chosen if the code is compiled in a <em>freestanding
 219:/usr/lib/avr/include/util/delay.h ****    environment</em> (GCC option \c -ffreestanding), as the math functions
 220:/usr/lib/avr/include/util/delay.h ****    required for rounding are not available to the compiler then.
 221:/usr/lib/avr/include/util/delay.h **** 
 222:/usr/lib/avr/include/util/delay.h ****  */
 223:/usr/lib/avr/include/util/delay.h **** void
 224:/usr/lib/avr/include/util/delay.h **** _delay_us(double __us)
 225:/usr/lib/avr/include/util/delay.h **** {
 226:/usr/lib/avr/include/util/delay.h **** 	uint8_t __ticks;
 227:/usr/lib/avr/include/util/delay.h **** 	double __tmp ; 
 228:/usr/lib/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 229:/usr/lib/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 230:/usr/lib/avr/include/util/delay.h ****   __STDC_HOSTED__
 231:/usr/lib/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 232:/usr/lib/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 233:/usr/lib/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 234:/usr/lib/avr/include/util/delay.h **** 
 235:/usr/lib/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 236:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 237:/usr/lib/avr/include/util/delay.h **** 
 238:/usr/lib/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 239:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 240:/usr/lib/avr/include/util/delay.h **** 
 241:/usr/lib/avr/include/util/delay.h **** 	#else
 242:/usr/lib/avr/include/util/delay.h **** 		//round up by default
 243:/usr/lib/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 244:/usr/lib/avr/include/util/delay.h **** 	#endif
 245:/usr/lib/avr/include/util/delay.h **** 
 246:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 202               		.loc 2 246 0
 203 0056 80EA      		ldi r24,lo8(-96)
 204 0058 8A95      		1: dec r24
 205 005a 01F4      		brne 1b
 206               	.LBE37:
 207               	.LBE36:
 208               	.LBB38:
 209               	.LBB39:
 112:matrix.c      ****     return (PINC&(1<<0) ? 0 : (1<<0)) |
 210               		.loc 1 112 0
 211 005c 26B1      		in r18,0x6
 212 005e 2170      		andi r18,lo8(1)
 213 0060 2027      		eor r18,r16
 214 0062 30E0      		ldi r19,0
 113:matrix.c      ****            (PINC&(1<<1) ? 0 : (1<<1)) |
 215               		.loc 1 113 0
 216 0064 319B      		sbis 0x6,1
 217 0066 00C0      		rjmp .L41
 218 0068 80E0      		ldi r24,0
 219 006a 90E0      		ldi r25,0
 220 006c 00C0      		rjmp .L15
 221               	.L41:
 222 006e 82E0      		ldi r24,lo8(2)
 223 0070 90E0      		ldi r25,0
 224               	.L15:
 112:matrix.c      ****     return (PINC&(1<<0) ? 0 : (1<<0)) |
 225               		.loc 1 112 0
 226 0072 282B      		or r18,r24
 227 0074 392B      		or r19,r25
 114:matrix.c      ****            (PINC&(1<<2) ? 0 : (1<<2)) |
 228               		.loc 1 114 0
 229 0076 329B      		sbis 0x6,2
 230 0078 00C0      		rjmp .L42
 231 007a 80E0      		ldi r24,0
 232 007c 90E0      		ldi r25,0
 233 007e 00C0      		rjmp .L16
 234               	.L42:
 235 0080 84E0      		ldi r24,lo8(4)
 236 0082 90E0      		ldi r25,0
 237               	.L16:
 113:matrix.c      ****            (PINC&(1<<1) ? 0 : (1<<1)) |
 238               		.loc 1 113 0
 239 0084 822B      		or r24,r18
 240 0086 932B      		or r25,r19
 115:matrix.c      ****            (PINC&(1<<3) ? 0 : (1<<3)) |
 241               		.loc 1 115 0
 242 0088 339B      		sbis 0x6,3
 243 008a 00C0      		rjmp .L43
 244 008c 60E0      		ldi r22,0
 245 008e 70E0      		ldi r23,0
 246 0090 00C0      		rjmp .L17
 247               	.L43:
 248 0092 68E0      		ldi r22,lo8(8)
 249 0094 70E0      		ldi r23,0
 250               	.L17:
 114:matrix.c      ****            (PINC&(1<<2) ? 0 : (1<<2)) |
 251               		.loc 1 114 0
 252 0096 9C01      		movw r18,r24
 253 0098 262B      		or r18,r22
 254 009a 372B      		or r19,r23
 116:matrix.c      ****            (PINC&(1<<4) ? 0 : (1<<4)) |
 255               		.loc 1 116 0
 256 009c 349B      		sbis 0x6,4
 257 009e 00C0      		rjmp .L44
 258 00a0 40E0      		ldi r20,0
 259 00a2 50E0      		ldi r21,0
 260 00a4 00C0      		rjmp .L18
 261               	.L44:
 262 00a6 40E1      		ldi r20,lo8(16)
 263 00a8 50E0      		ldi r21,0
 264               	.L18:
 115:matrix.c      ****            (PINC&(1<<3) ? 0 : (1<<3)) |
 265               		.loc 1 115 0
 266 00aa 242B      		or r18,r20
 267 00ac 352B      		or r19,r21
 117:matrix.c      ****            (PINC&(1<<5) ? 0 : (1<<5)) |
 268               		.loc 1 117 0
 269 00ae 359B      		sbis 0x6,5
 270 00b0 00C0      		rjmp .L45
 271 00b2 80E0      		ldi r24,0
 272 00b4 90E0      		ldi r25,0
 273 00b6 00C0      		rjmp .L19
 274               	.L45:
 275 00b8 80E2      		ldi r24,lo8(32)
 276 00ba 90E0      		ldi r25,0
 277               	.L19:
 116:matrix.c      ****            (PINC&(1<<4) ? 0 : (1<<4)) |
 278               		.loc 1 116 0
 279 00bc 282B      		or r18,r24
 280 00be 392B      		or r19,r25
 118:matrix.c      ****            (PINC&(1<<6) ? 0 : (1<<6)) |
 281               		.loc 1 118 0
 282 00c0 369B      		sbis 0x6,6
 283 00c2 00C0      		rjmp .L46
 284 00c4 80E0      		ldi r24,0
 285 00c6 90E0      		ldi r25,0
 286 00c8 00C0      		rjmp .L20
 287               	.L46:
 288 00ca 80E4      		ldi r24,lo8(64)
 289 00cc 90E0      		ldi r25,0
 290               	.L20:
 117:matrix.c      ****            (PINC&(1<<5) ? 0 : (1<<5)) |
 291               		.loc 1 117 0
 292 00ce 282B      		or r18,r24
 293 00d0 392B      		or r19,r25
 119:matrix.c      ****            (PINC&(1<<7) ? 0 : (1<<7)) |
 294               		.loc 1 119 0
 295 00d2 86B1      		in r24,0x6
 296 00d4 9927      		clr r25
 297 00d6 87FD      		sbrc r24,7
 298 00d8 9095      		com r25
 299 00da 8095      		com r24
 300 00dc 9095      		com r25
 301 00de 8827      		clr r24
 302 00e0 990F      		lsl r25
 303 00e2 881F      		rol r24
 304 00e4 9927      		clr r25
 305 00e6 9695      		lsr r25
 306 00e8 982F      		mov r25,r24
 307 00ea 8827      		clr r24
 308 00ec 9795      		ror r25
 309 00ee 8795      		ror r24
 118:matrix.c      ****            (PINC&(1<<6) ? 0 : (1<<6)) |
 310               		.loc 1 118 0
 311 00f0 282B      		or r18,r24
 312 00f2 392B      		or r19,r25
 120:matrix.c      ****            (PINF&(1<<0) ? 0 : (1<<8)) |     
 313               		.loc 1 120 0
 314 00f4 789B      		sbis 0xf,0
 315 00f6 00C0      		rjmp .L48
 316 00f8 80E0      		ldi r24,0
 317 00fa 90E0      		ldi r25,0
 318 00fc 00C0      		rjmp .L22
 319               	.L48:
 320 00fe 80E0      		ldi r24,0
 321 0100 91E0      		ldi r25,lo8(1)
 322               	.L22:
 119:matrix.c      ****            (PINC&(1<<7) ? 0 : (1<<7)) |
 323               		.loc 1 119 0
 324 0102 282B      		or r18,r24
 325 0104 392B      		or r19,r25
 121:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<<9)) |
 326               		.loc 1 121 0
 327 0106 799B      		sbis 0xf,1
 328 0108 00C0      		rjmp .L49
 329 010a 80E0      		ldi r24,0
 330 010c 90E0      		ldi r25,0
 331 010e 00C0      		rjmp .L23
 332               	.L49:
 333 0110 80E0      		ldi r24,0
 334 0112 92E0      		ldi r25,lo8(2)
 335               	.L23:
 120:matrix.c      ****            (PINF&(1<<0) ? 0 : (1<<8)) |     
 336               		.loc 1 120 0
 337 0114 282B      		or r18,r24
 338 0116 392B      		or r19,r25
 122:matrix.c      ****            (PINF&(1<<2) ? 0 : (1<<10)) |
 339               		.loc 1 122 0
 340 0118 7A9B      		sbis 0xf,2
 341 011a 00C0      		rjmp .L50
 342 011c 60E0      		ldi r22,0
 343 011e 70E0      		ldi r23,0
 344 0120 00C0      		rjmp .L24
 345               	.L50:
 346 0122 60E0      		ldi r22,0
 347 0124 74E0      		ldi r23,lo8(4)
 348               	.L24:
 121:matrix.c      ****            (PINF&(1<<1) ? 0 : (1<<9)) |
 349               		.loc 1 121 0
 350 0126 262B      		or r18,r22
 351 0128 372B      		or r19,r23
 123:matrix.c      ****            (PINF&(1<<3) ? 0 : (1<<11)) |
 352               		.loc 1 123 0
 353 012a 7B9B      		sbis 0xf,3
 354 012c 00C0      		rjmp .L51
 355 012e 40E0      		ldi r20,0
 356 0130 50E0      		ldi r21,0
 357 0132 00C0      		rjmp .L25
 358               	.L51:
 359 0134 40E0      		ldi r20,0
 360 0136 58E0      		ldi r21,lo8(8)
 361               	.L25:
 122:matrix.c      ****            (PINF&(1<<2) ? 0 : (1<<10)) |
 362               		.loc 1 122 0
 363 0138 242B      		or r18,r20
 364 013a 352B      		or r19,r21
 124:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<12)) |
 365               		.loc 1 124 0
 366 013c 7C9B      		sbis 0xf,4
 367 013e 00C0      		rjmp .L52
 368 0140 80E0      		ldi r24,0
 369 0142 90E0      		ldi r25,0
 370 0144 00C0      		rjmp .L26
 371               	.L52:
 372 0146 80E0      		ldi r24,0
 373 0148 90E1      		ldi r25,lo8(16)
 374               	.L26:
 123:matrix.c      ****            (PINF&(1<<3) ? 0 : (1<<11)) |
 375               		.loc 1 123 0
 376 014a 282B      		or r18,r24
 377 014c 392B      		or r19,r25
 125:matrix.c      ****            (PINF&(1<<5) ? 0 : (1<<13));
 378               		.loc 1 125 0
 379 014e 7D9B      		sbis 0xf,5
 380 0150 00C0      		rjmp .L53
 381 0152 80E0      		ldi r24,0
 382 0154 90E0      		ldi r25,0
 383 0156 00C0      		rjmp .L27
 384               	.L53:
 385 0158 80E0      		ldi r24,0
 386 015a 90E2      		ldi r25,lo8(32)
 387               	.L27:
 124:matrix.c      ****            (PINF&(1<<4) ? 0 : (1<<12)) |
 388               		.loc 1 124 0
 389 015c 282B      		or r18,r24
 390 015e 392B      		or r19,r25
 391               	.LBE39:
 392               	.LBE38:
  65:matrix.c      ****         if (matrix_debouncing[i] != cols) {
 393               		.loc 1 65 0
 394 0160 8881      		ld r24,Y
 395 0162 9981      		ldd r25,Y+1
 396 0164 8217      		cp r24,r18
 397 0166 9307      		cpc r25,r19
 398 0168 01F0      		breq .L28
  66:matrix.c      ****             matrix_debouncing[i] = cols;
 399               		.loc 1 66 0
 400 016a 3983      		std Y+1,r19
 401 016c 2883      		st Y,r18
  67:matrix.c      ****             if (debouncing) {
 402               		.loc 1 67 0
 403 016e 8091 0000 		lds r24,debouncing
 404 0172 8823      		tst r24
 405 0174 01F0      		breq .L30
  68:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 406               		.loc 1 68 0
 407 0176 8091 0000 		lds r24,debug_config
 408 017a 80FF      		sbrs r24,0
 409 017c 00C0      		rjmp .L31
  68:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 410               		.loc 1 68 0 is_stmt 0 discriminator 1
 411 017e 80E0      		ldi r24,lo8(__c.1885)
 412 0180 90E0      		ldi r25,hi8(__c.1885)
 413 0182 0E94 0000 		call xputs
 414               	.LVL6:
 415               	.L31:
  68:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 416               		.loc 1 68 0 discriminator 2
 417 0186 8091 0000 		lds r24,debug_config
 418 018a 80FF      		sbrs r24,0
 419 018c 00C0      		rjmp .L32
  68:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 420               		.loc 1 68 0 discriminator 1
 421 018e 8091 0000 		lds r24,debouncing
 422 0192 1F92      		push __zero_reg__
 423               	.LCFI6:
 424               		.cfi_def_cfa_offset 9
 425 0194 8F93      		push r24
 426               	.LCFI7:
 427               		.cfi_def_cfa_offset 10
 428 0196 FF92      		push r15
 429               	.LCFI8:
 430               		.cfi_def_cfa_offset 11
 431 0198 EF92      		push r14
 432               	.LCFI9:
 433               		.cfi_def_cfa_offset 12
 434 019a 0E94 0000 		call __xprintf
 435               	.LVL7:
 436 019e 0F90      		pop __tmp_reg__
 437 01a0 0F90      		pop __tmp_reg__
 438 01a2 0F90      		pop __tmp_reg__
 439 01a4 0F90      		pop __tmp_reg__
 440               	.LCFI10:
 441               		.cfi_def_cfa_offset 8
 442               	.L32:
  68:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 443               		.loc 1 68 0 discriminator 2
 444 01a6 8091 0000 		lds r24,debug_config
 445 01aa 80FF      		sbrs r24,0
 446 01ac 00C0      		rjmp .L30
  68:matrix.c      ****                 debug("bounce!: "); debug_hex(debouncing); debug("\n");
 447               		.loc 1 68 0 discriminator 1
 448 01ae 80E0      		ldi r24,lo8(__c.1889)
 449 01b0 90E0      		ldi r25,hi8(__c.1889)
 450 01b2 0E94 0000 		call xputs
 451               	.LVL8:
 452               	.L30:
  70:matrix.c      ****             debouncing = DEBOUNCE;
 453               		.loc 1 70 0 is_stmt 1
 454 01b6 85E0      		ldi r24,lo8(5)
 455 01b8 8093 0000 		sts debouncing,r24
 456               	.L28:
  72:matrix.c      ****         unselect_rows();
 457               		.loc 1 72 0
 458 01bc 0E94 0000 		call unselect_rows
 459               	.LVL9:
 460               	.LBE33:
  61:matrix.c      ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 461               		.loc 1 61 0
 462 01c0 1F5F      		subi r17,lo8(-(1))
 463               	.LVL10:
 464 01c2 2296      		adiw r28,2
 465 01c4 1630      		cpi r17,lo8(6)
 466 01c6 01F0      		breq .+2
 467 01c8 00C0      		rjmp .L35
 468               	.LBE32:
  75:matrix.c      ****     if (debouncing) {
 469               		.loc 1 75 0
 470 01ca 8091 0000 		lds r24,debouncing
 471 01ce 8823      		tst r24
 472 01d0 01F0      		breq .L37
  76:matrix.c      ****         if (--debouncing) {
 473               		.loc 1 76 0
 474 01d2 8150      		subi r24,lo8(-(-1))
 475 01d4 8093 0000 		sts debouncing,r24
 476 01d8 8823      		tst r24
 477 01da 01F0      		breq .L38
 478               	.LVL11:
 479               	.LBB40:
 480               	.LBB41:
 164:/usr/lib/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 481               		.loc 2 164 0
 482 01dc 8FE9      		ldi r24,lo8(3999)
 483 01de 9FE0      		ldi r25,hi8(3999)
 484 01e0 0197      		1: sbiw r24,1
 485 01e2 01F4      		brne 1b
 486 01e4 00C0      		rjmp .
 487 01e6 0000      		nop
 488 01e8 00C0      		rjmp .L37
 489               	.LVL12:
 490               	.L38:
 491 01ea A0E0      		ldi r26,lo8(matrix)
 492 01ec B0E0      		ldi r27,hi8(matrix)
 493               	.LBE41:
 494               	.LBE40:
  76:matrix.c      ****         if (--debouncing) {
 495               		.loc 1 76 0
 496 01ee E0E0      		ldi r30,lo8(matrix_debouncing)
 497 01f0 F0E0      		ldi r31,hi8(matrix_debouncing)
 498               	.L40:
 499               	.LBB42:
  80:matrix.c      ****                 matrix[i] = matrix_debouncing[i];
 500               		.loc 1 80 0 discriminator 2
 501 01f2 8191      		ld r24,Z+
 502 01f4 9191      		ld r25,Z+
 503 01f6 8D93      		st X+,r24
 504 01f8 9D93      		st X+,r25
 505               	.LVL13:
  79:matrix.c      ****             for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 506               		.loc 1 79 0 discriminator 2
 507 01fa 90E0      		ldi r25,hi8(matrix_debouncing+12)
 508 01fc E030      		cpi r30,lo8(matrix_debouncing+12)
 509 01fe F907      		cpc r31,r25
 510 0200 01F4      		brne .L40
 511               	.L37:
 512               	.LBE42:
  86:matrix.c      **** }
 513               		.loc 1 86 0
 514 0202 81E0      		ldi r24,lo8(1)
 515               	/* epilogue start */
 516 0204 DF91      		pop r29
 517 0206 CF91      		pop r28
 518 0208 1F91      		pop r17
 519               	.LVL14:
 520 020a 0F91      		pop r16
 521 020c FF90      		pop r15
 522 020e EF90      		pop r14
 523 0210 0895      		ret
 524               		.cfi_endproc
 525               	.LFE8:
 527               		.section	.text.matrix_get_row,"ax",@progbits
 528               	.global	matrix_get_row
 530               	matrix_get_row:
 531               	.LFB9:
  90:matrix.c      **** {
 532               		.loc 1 90 0
 533               		.cfi_startproc
 534               	.LVL15:
 535               	/* prologue: function */
 536               	/* frame size = 0 */
 537               	/* stack size = 0 */
 538               	.L__stack_usage = 0
  91:matrix.c      ****     return matrix[row];
 539               		.loc 1 91 0
 540 0000 E82F      		mov r30,r24
 541 0002 F0E0      		ldi r31,0
 542 0004 EE0F      		lsl r30
 543 0006 FF1F      		rol r31
 544 0008 E050      		subi r30,lo8(-(matrix))
 545 000a F040      		sbci r31,hi8(-(matrix))
  92:matrix.c      **** }
 546               		.loc 1 92 0
 547 000c 8081      		ld r24,Z
 548 000e 9181      		ldd r25,Z+1
 549               	.LVL16:
 550 0010 0895      		ret
 551               		.cfi_endproc
 552               	.LFE9:
 554               		.section	.progmem.data.__c.1889,"a",@progbits
 557               	__c.1889:
 558 0000 0A00      		.string	"\n"
 559               		.section	.progmem.data.__c.1887,"a",@progbits
 562               	__c.1887:
 563 0000 2530 3258 		.string	"%02X"
 563      00
 564               		.section	.progmem.data.__c.1885,"a",@progbits
 567               	__c.1885:
 568 0000 626F 756E 		.string	"bounce!: "
 568      6365 213A 
 568      2000 
 569               		.section	.bss.matrix_debouncing,"aw",@nobits
 572               	matrix_debouncing:
 573 0000 0000 0000 		.zero	12
 573      0000 0000 
 573      0000 0000 
 574               		.section	.bss.matrix,"aw",@nobits
 577               	matrix:
 578 0000 0000 0000 		.zero	12
 578      0000 0000 
 578      0000 0000 
 579               		.section	.data.debouncing,"aw",@progbits
 582               	debouncing:
 583 0000 05        		.byte	5
 584               		.text
 585               	.Letext0:
 586               		.file 3 "/usr/lib/avr/include/stdint.h"
 587               		.file 4 "../../tmk_core/common/debug.h"
 588               		.file 5 "../../tmk_core/common/matrix.h"
 589               		.file 6 "../../tmk_core/common/avr/xprintf.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccEZi7rU.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccEZi7rU.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccEZi7rU.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccEZi7rU.s:5      *ABS*:000000000000003b __RAMPZ__
     /tmp/ccEZi7rU.s:6      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccEZi7rU.s:7      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccEZi7rU.s:13     .text.unselect_rows:0000000000000000 unselect_rows
     /tmp/ccEZi7rU.s:37     .text.matrix_init:0000000000000000 matrix_init
     /tmp/ccEZi7rU.s:577    .bss.matrix:0000000000000000 matrix
     /tmp/ccEZi7rU.s:572    .bss.matrix_debouncing:0000000000000000 matrix_debouncing
     /tmp/ccEZi7rU.s:96     .text.matrix_scan:0000000000000000 matrix_scan
     /tmp/ccEZi7rU.s:562    .progmem.data.__c.1887:0000000000000000 __c.1887
     /tmp/ccEZi7rU.s:582    .data.debouncing:0000000000000000 debouncing
     /tmp/ccEZi7rU.s:567    .progmem.data.__c.1885:0000000000000000 __c.1885
     /tmp/ccEZi7rU.s:557    .progmem.data.__c.1889:0000000000000000 __c.1889
     /tmp/ccEZi7rU.s:530    .text.matrix_get_row:0000000000000000 matrix_get_row

UNDEFINED SYMBOLS
debug_config
xputs
__xprintf
__do_copy_data
__do_clear_bss
